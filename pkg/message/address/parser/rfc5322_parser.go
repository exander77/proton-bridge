// Code generated from pkg/message/address/parser/RFC5322Parser.g4 by ANTLR 4.8. DO NOT EDIT.

package parser // RFC5322Parser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 72, 768,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 3, 2, 3, 2, 5, 2, 113, 10, 2, 3, 3, 3, 3, 3, 3, 5, 3, 118, 10, 3,
	3, 4, 7, 4, 121, 10, 4, 12, 4, 14, 4, 124, 11, 4, 3, 4, 5, 4, 127, 10,
	4, 3, 4, 6, 4, 130, 10, 4, 13, 4, 14, 4, 131, 3, 4, 5, 4, 135, 10, 4, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 170, 10, 5, 3,
	6, 3, 6, 3, 6, 5, 6, 175, 10, 6, 3, 7, 3, 7, 5, 7, 179, 10, 7, 3, 7, 7,
	7, 182, 10, 7, 12, 7, 14, 7, 185, 11, 7, 3, 7, 5, 7, 188, 10, 7, 3, 7,
	3, 7, 3, 8, 5, 8, 193, 10, 8, 3, 8, 6, 8, 196, 10, 8, 13, 8, 14, 8, 197,
	3, 8, 5, 8, 201, 10, 8, 3, 8, 5, 8, 204, 10, 8, 3, 9, 3, 9, 3, 9, 3, 9,
	3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9,
	3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 5, 9, 228, 10, 9, 3, 10, 6, 10, 231,
	10, 10, 13, 10, 14, 10, 232, 3, 11, 6, 11, 236, 10, 11, 13, 11, 14, 11,
	237, 3, 11, 3, 11, 6, 11, 242, 10, 11, 13, 11, 14, 11, 243, 7, 11, 246,
	10, 11, 12, 11, 14, 11, 249, 11, 11, 3, 11, 5, 11, 252, 10, 11, 3, 12,
	3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3,
	12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12,
	3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3,
	12, 3, 12, 5, 12, 288, 10, 12, 3, 13, 3, 13, 5, 13, 292, 10, 13, 3, 14,
	5, 14, 295, 10, 14, 3, 14, 7, 14, 298, 10, 14, 12, 14, 14, 14, 301, 11,
	14, 3, 15, 3, 15, 3, 15, 5, 15, 306, 10, 15, 3, 15, 3, 15, 3, 16, 5, 16,
	311, 10, 16, 3, 16, 3, 16, 5, 16, 315, 10, 16, 3, 16, 5, 16, 318, 10, 16,
	3, 16, 3, 16, 5, 16, 322, 10, 16, 3, 16, 5, 16, 325, 10, 16, 3, 16, 3,
	16, 5, 16, 329, 10, 16, 3, 16, 5, 16, 332, 10, 16, 3, 17, 3, 17, 5, 17,
	336, 10, 17, 3, 18, 3, 18, 5, 18, 340, 10, 18, 3, 19, 5, 19, 343, 10, 19,
	3, 19, 3, 19, 3, 20, 5, 20, 348, 10, 20, 3, 20, 3, 20, 5, 20, 352, 10,
	20, 3, 20, 3, 20, 5, 20, 356, 10, 20, 3, 20, 5, 20, 359, 10, 20, 3, 21,
	3, 21, 3, 21, 5, 21, 364, 10, 21, 3, 21, 3, 21, 5, 21, 368, 10, 21, 3,
	22, 6, 22, 371, 10, 22, 13, 22, 14, 22, 372, 3, 22, 3, 22, 3, 22, 3, 22,
	7, 22, 379, 10, 22, 12, 22, 14, 22, 382, 11, 22, 5, 22, 384, 10, 22, 3,
	23, 3, 23, 3, 23, 7, 23, 389, 10, 23, 12, 23, 14, 23, 392, 11, 23, 3, 23,
	5, 23, 395, 10, 23, 3, 24, 3, 24, 3, 24, 7, 24, 400, 10, 24, 12, 24, 14,
	24, 403, 11, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 410, 10, 24,
	3, 25, 3, 25, 3, 25, 5, 25, 415, 10, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3,
	26, 5, 26, 422, 10, 26, 3, 27, 5, 27, 425, 10, 27, 3, 27, 3, 27, 5, 27,
	429, 10, 27, 3, 27, 5, 27, 432, 10, 27, 3, 27, 3, 27, 5, 27, 436, 10, 27,
	3, 27, 5, 27, 439, 10, 27, 3, 28, 6, 28, 442, 10, 28, 13, 28, 14, 28, 443,
	3, 29, 5, 29, 447, 10, 29, 3, 29, 3, 29, 5, 29, 451, 10, 29, 3, 29, 5,
	29, 454, 10, 29, 3, 29, 3, 29, 5, 29, 458, 10, 29, 3, 29, 5, 29, 461, 10,
	29, 3, 29, 3, 29, 5, 29, 465, 10, 29, 5, 29, 467, 10, 29, 3, 30, 3, 30,
	5, 30, 471, 10, 30, 3, 30, 7, 30, 474, 10, 30, 12, 30, 14, 30, 477, 11,
	30, 3, 30, 5, 30, 480, 10, 30, 3, 30, 3, 30, 3, 31, 3, 31, 3, 31, 3, 31,
	3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3,
	31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31,
	3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31, 516, 10, 31, 3,
	32, 3, 32, 3, 33, 3, 33, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	5, 35, 529, 10, 35, 3, 36, 6, 36, 532, 10, 36, 13, 36, 14, 36, 533, 3,
	36, 3, 36, 6, 36, 538, 10, 36, 13, 36, 14, 36, 539, 3, 37, 5, 37, 543,
	10, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 550, 10, 37, 3, 38, 3,
	38, 3, 38, 3, 39, 3, 39, 7, 39, 557, 10, 39, 12, 39, 14, 39, 560, 11, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 566, 10, 39, 3, 39, 3, 39, 5, 39, 570,
	10, 39, 7, 39, 572, 10, 39, 12, 39, 14, 39, 575, 11, 39, 3, 40, 5, 40,
	578, 10, 40, 3, 40, 7, 40, 581, 10, 40, 12, 40, 14, 40, 584, 11, 40, 3,
	40, 3, 40, 3, 40, 3, 40, 5, 40, 590, 10, 40, 7, 40, 592, 10, 40, 12, 40,
	14, 40, 595, 11, 40, 3, 41, 5, 41, 598, 10, 41, 3, 41, 7, 41, 601, 10,
	41, 12, 41, 14, 41, 604, 11, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 610,
	10, 41, 7, 41, 612, 10, 41, 12, 41, 14, 41, 615, 11, 41, 3, 42, 5, 42,
	618, 10, 42, 3, 42, 6, 42, 621, 10, 42, 13, 42, 14, 42, 622, 3, 42, 5,
	42, 626, 10, 42, 3, 43, 3, 43, 3, 43, 7, 43, 631, 10, 43, 12, 43, 14, 43,
	634, 11, 43, 3, 44, 3, 44, 3, 44, 7, 44, 639, 10, 44, 12, 44, 14, 44, 642,
	11, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45,
	3, 45, 3, 46, 3, 46, 3, 47, 3, 47, 3, 48, 6, 48, 659, 10, 48, 13, 48, 14,
	48, 660, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49,
	3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 5,
	49, 682, 10, 49, 3, 50, 6, 50, 685, 10, 50, 13, 50, 14, 50, 686, 3, 51,
	3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3,
	51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51,
	3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3,
	51, 5, 51, 722, 10, 51, 3, 52, 3, 52, 3, 52, 3, 53, 3, 53, 3, 54, 3, 54,
	3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3,
	54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54,
	3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3,
	54, 3, 54, 5, 54, 764, 10, 54, 3, 55, 3, 55, 3, 55, 2, 2, 56, 2, 4, 6,
	8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
	44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
	80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 2, 5,
	6, 2, 4, 4, 7, 8, 10, 10, 45, 45, 4, 2, 5, 5, 11, 11, 3, 2, 47, 72, 2,
	1015, 2, 112, 3, 2, 2, 2, 4, 117, 3, 2, 2, 2, 6, 134, 3, 2, 2, 2, 8, 169,
	3, 2, 2, 2, 10, 174, 3, 2, 2, 2, 12, 176, 3, 2, 2, 2, 14, 203, 3, 2, 2,
	2, 16, 227, 3, 2, 2, 2, 18, 230, 3, 2, 2, 2, 20, 235, 3, 2, 2, 2, 22, 287,
	3, 2, 2, 2, 24, 291, 3, 2, 2, 2, 26, 299, 3, 2, 2, 2, 28, 302, 3, 2, 2,
	2, 30, 331, 3, 2, 2, 2, 32, 335, 3, 2, 2, 2, 34, 339, 3, 2, 2, 2, 36, 342,
	3, 2, 2, 2, 38, 358, 3, 2, 2, 2, 40, 360, 3, 2, 2, 2, 42, 383, 3, 2, 2,
	2, 44, 394, 3, 2, 2, 2, 46, 409, 3, 2, 2, 2, 48, 414, 3, 2, 2, 2, 50, 416,
	3, 2, 2, 2, 52, 438, 3, 2, 2, 2, 54, 441, 3, 2, 2, 2, 56, 466, 3, 2, 2,
	2, 58, 468, 3, 2, 2, 2, 60, 515, 3, 2, 2, 2, 62, 517, 3, 2, 2, 2, 64, 519,
	3, 2, 2, 2, 66, 521, 3, 2, 2, 2, 68, 523, 3, 2, 2, 2, 70, 531, 3, 2, 2,
	2, 72, 542, 3, 2, 2, 2, 74, 551, 3, 2, 2, 2, 76, 558, 3, 2, 2, 2, 78, 582,
	3, 2, 2, 2, 80, 602, 3, 2, 2, 2, 82, 620, 3, 2, 2, 2, 84, 627, 3, 2, 2,
	2, 86, 635, 3, 2, 2, 2, 88, 643, 3, 2, 2, 2, 90, 653, 3, 2, 2, 2, 92, 655,
	3, 2, 2, 2, 94, 658, 3, 2, 2, 2, 96, 681, 3, 2, 2, 2, 98, 684, 3, 2, 2,
	2, 100, 721, 3, 2, 2, 2, 102, 723, 3, 2, 2, 2, 104, 726, 3, 2, 2, 2, 106,
	763, 3, 2, 2, 2, 108, 765, 3, 2, 2, 2, 110, 113, 5, 106, 54, 2, 111, 113,
	5, 104, 53, 2, 112, 110, 3, 2, 2, 2, 112, 111, 3, 2, 2, 2, 113, 3, 3, 2,
	2, 2, 114, 115, 7, 36, 2, 2, 115, 118, 5, 2, 2, 2, 116, 118, 5, 68, 35,
	2, 117, 114, 3, 2, 2, 2, 117, 116, 3, 2, 2, 2, 118, 5, 3, 2, 2, 2, 119,
	121, 5, 104, 53, 2, 120, 119, 3, 2, 2, 2, 121, 124, 3, 2, 2, 2, 122, 120,
	3, 2, 2, 2, 122, 123, 3, 2, 2, 2, 123, 125, 3, 2, 2, 2, 124, 122, 3, 2,
	2, 2, 125, 127, 5, 102, 52, 2, 126, 122, 3, 2, 2, 2, 126, 127, 3, 2, 2,
	2, 127, 129, 3, 2, 2, 2, 128, 130, 5, 104, 53, 2, 129, 128, 3, 2, 2, 2,
	130, 131, 3, 2, 2, 2, 131, 129, 3, 2, 2, 2, 131, 132, 3, 2, 2, 2, 132,
	135, 3, 2, 2, 2, 133, 135, 5, 70, 36, 2, 134, 126, 3, 2, 2, 2, 134, 133,
	3, 2, 2, 2, 135, 7, 3, 2, 2, 2, 136, 170, 5, 108, 55, 2, 137, 170, 7, 12,
	2, 2, 138, 170, 7, 13, 2, 2, 139, 170, 7, 14, 2, 2, 140, 170, 7, 15, 2,
	2, 141, 170, 7, 16, 2, 2, 142, 170, 7, 17, 2, 2, 143, 170, 7, 18, 2, 2,
	144, 170, 7, 21, 2, 2, 145, 170, 7, 22, 2, 2, 146, 170, 7, 23, 2, 2, 147,
	170, 7, 24, 2, 2, 148, 170, 7, 25, 2, 2, 149, 170, 7, 26, 2, 2, 150, 170,
	7, 27, 2, 2, 151, 170, 7, 28, 2, 2, 152, 170, 7, 29, 2, 2, 153, 170, 7,
	30, 2, 2, 154, 170, 7, 31, 2, 2, 155, 170, 7, 32, 2, 2, 156, 170, 7, 33,
	2, 2, 157, 170, 7, 34, 2, 2, 158, 170, 7, 35, 2, 2, 159, 170, 7, 37, 2,
	2, 160, 170, 7, 38, 2, 2, 161, 170, 7, 39, 2, 2, 162, 170, 7, 40, 2, 2,
	163, 170, 7, 41, 2, 2, 164, 170, 7, 42, 2, 2, 165, 170, 7, 43, 2, 2, 166,
	170, 7, 44, 2, 2, 167, 170, 5, 64, 33, 2, 168, 170, 7, 46, 2, 2, 169, 136,
	3, 2, 2, 2, 169, 137, 3, 2, 2, 2, 169, 138, 3, 2, 2, 2, 169, 139, 3, 2,
	2, 2, 169, 140, 3, 2, 2, 2, 169, 141, 3, 2, 2, 2, 169, 142, 3, 2, 2, 2,
	169, 143, 3, 2, 2, 2, 169, 144, 3, 2, 2, 2, 169, 145, 3, 2, 2, 2, 169,
	146, 3, 2, 2, 2, 169, 147, 3, 2, 2, 2, 169, 148, 3, 2, 2, 2, 169, 149,
	3, 2, 2, 2, 169, 150, 3, 2, 2, 2, 169, 151, 3, 2, 2, 2, 169, 152, 3, 2,
	2, 2, 169, 153, 3, 2, 2, 2, 169, 154, 3, 2, 2, 2, 169, 155, 3, 2, 2, 2,
	169, 156, 3, 2, 2, 2, 169, 157, 3, 2, 2, 2, 169, 158, 3, 2, 2, 2, 169,
	159, 3, 2, 2, 2, 169, 160, 3, 2, 2, 2, 169, 161, 3, 2, 2, 2, 169, 162,
	3, 2, 2, 2, 169, 163, 3, 2, 2, 2, 169, 164, 3, 2, 2, 2, 169, 165, 3, 2,
	2, 2, 169, 166, 3, 2, 2, 2, 169, 167, 3, 2, 2, 2, 169, 168, 3, 2, 2, 2,
	170, 9, 3, 2, 2, 2, 171, 175, 5, 8, 5, 2, 172, 175, 5, 4, 3, 2, 173, 175,
	5, 12, 7, 2, 174, 171, 3, 2, 2, 2, 174, 172, 3, 2, 2, 2, 174, 173, 3, 2,
	2, 2, 175, 11, 3, 2, 2, 2, 176, 183, 7, 19, 2, 2, 177, 179, 5, 6, 4, 2,
	178, 177, 3, 2, 2, 2, 178, 179, 3, 2, 2, 2, 179, 180, 3, 2, 2, 2, 180,
	182, 5, 10, 6, 2, 181, 178, 3, 2, 2, 2, 182, 185, 3, 2, 2, 2, 183, 181,
	3, 2, 2, 2, 183, 184, 3, 2, 2, 2, 184, 187, 3, 2, 2, 2, 185, 183, 3, 2,
	2, 2, 186, 188, 5, 6, 4, 2, 187, 186, 3, 2, 2, 2, 187, 188, 3, 2, 2, 2,
	188, 189, 3, 2, 2, 2, 189, 190, 7, 20, 2, 2, 190, 13, 3, 2, 2, 2, 191,
	193, 5, 6, 4, 2, 192, 191, 3, 2, 2, 2, 192, 193, 3, 2, 2, 2, 193, 194,
	3, 2, 2, 2, 194, 196, 5, 12, 7, 2, 195, 192, 3, 2, 2, 2, 196, 197, 3, 2,
	2, 2, 197, 195, 3, 2, 2, 2, 197, 198, 3, 2, 2, 2, 198, 200, 3, 2, 2, 2,
	199, 201, 5, 6, 4, 2, 200, 199, 3, 2, 2, 2, 200, 201, 3, 2, 2, 2, 201,
	204, 3, 2, 2, 2, 202, 204, 5, 6, 4, 2, 203, 195, 3, 2, 2, 2, 203, 202,
	3, 2, 2, 2, 204, 15, 3, 2, 2, 2, 205, 228, 5, 108, 55, 2, 206, 228, 7,
	27, 2, 2, 207, 228, 7, 12, 2, 2, 208, 228, 7, 14, 2, 2, 209, 228, 7, 15,
	2, 2, 210, 228, 7, 16, 2, 2, 211, 228, 7, 17, 2, 2, 212, 228, 7, 18, 2,
	2, 213, 228, 7, 21, 2, 2, 214, 228, 7, 22, 2, 2, 215, 228, 7, 24, 2, 2,
	216, 228, 7, 26, 2, 2, 217, 228, 7, 31, 2, 2, 218, 228, 7, 33, 2, 2, 219,
	228, 7, 38, 2, 2, 220, 228, 7, 39, 2, 2, 221, 228, 7, 40, 2, 2, 222, 228,
	7, 41, 2, 2, 223, 228, 7, 42, 2, 2, 224, 228, 7, 43, 2, 2, 225, 228, 7,
	44, 2, 2, 226, 228, 7, 46, 2, 2, 227, 205, 3, 2, 2, 2, 227, 206, 3, 2,
	2, 2, 227, 207, 3, 2, 2, 2, 227, 208, 3, 2, 2, 2, 227, 209, 3, 2, 2, 2,
	227, 210, 3, 2, 2, 2, 227, 211, 3, 2, 2, 2, 227, 212, 3, 2, 2, 2, 227,
	213, 3, 2, 2, 2, 227, 214, 3, 2, 2, 2, 227, 215, 3, 2, 2, 2, 227, 216,
	3, 2, 2, 2, 227, 217, 3, 2, 2, 2, 227, 218, 3, 2, 2, 2, 227, 219, 3, 2,
	2, 2, 227, 220, 3, 2, 2, 2, 227, 221, 3, 2, 2, 2, 227, 222, 3, 2, 2, 2,
	227, 223, 3, 2, 2, 2, 227, 224, 3, 2, 2, 2, 227, 225, 3, 2, 2, 2, 227,
	226, 3, 2, 2, 2, 228, 17, 3, 2, 2, 2, 229, 231, 5, 16, 9, 2, 230, 229,
	3, 2, 2, 2, 231, 232, 3, 2, 2, 2, 232, 230, 3, 2, 2, 2, 232, 233, 3, 2,
	2, 2, 233, 19, 3, 2, 2, 2, 234, 236, 5, 16, 9, 2, 235, 234, 3, 2, 2, 2,
	236, 237, 3, 2, 2, 2, 237, 235, 3, 2, 2, 2, 237, 238, 3, 2, 2, 2, 238,
	247, 3, 2, 2, 2, 239, 241, 7, 25, 2, 2, 240, 242, 5, 16, 9, 2, 241, 240,
	3, 2, 2, 2, 242, 243, 3, 2, 2, 2, 243, 241, 3, 2, 2, 2, 243, 244, 3, 2,
	2, 2, 244, 246, 3, 2, 2, 2, 245, 239, 3, 2, 2, 2, 246, 249, 3, 2, 2, 2,
	247, 245, 3, 2, 2, 2, 247, 248, 3, 2, 2, 2, 248, 251, 3, 2, 2, 2, 249,
	247, 3, 2, 2, 2, 250, 252, 7, 25, 2, 2, 251, 250, 3, 2, 2, 2, 251, 252,
	3, 2, 2, 2, 252, 21, 3, 2, 2, 2, 253, 288, 5, 108, 55, 2, 254, 288, 7,
	12, 2, 2, 255, 288, 7, 14, 2, 2, 256, 288, 7, 15, 2, 2, 257, 288, 7, 16,
	2, 2, 258, 288, 7, 17, 2, 2, 259, 288, 7, 18, 2, 2, 260, 288, 7, 19, 2,
	2, 261, 288, 7, 20, 2, 2, 262, 288, 7, 21, 2, 2, 263, 288, 7, 22, 2, 2,
	264, 288, 7, 23, 2, 2, 265, 288, 7, 24, 2, 2, 266, 288, 7, 25, 2, 2, 267,
	288, 7, 26, 2, 2, 268, 288, 7, 27, 2, 2, 269, 288, 7, 28, 2, 2, 270, 288,
	7, 29, 2, 2, 271, 288, 7, 30, 2, 2, 272, 288, 7, 31, 2, 2, 273, 288, 7,
	32, 2, 2, 274, 288, 7, 33, 2, 2, 275, 288, 7, 34, 2, 2, 276, 288, 7, 35,
	2, 2, 277, 288, 7, 37, 2, 2, 278, 288, 7, 38, 2, 2, 279, 288, 7, 39, 2,
	2, 280, 288, 7, 40, 2, 2, 281, 288, 7, 41, 2, 2, 282, 288, 7, 42, 2, 2,
	283, 288, 7, 43, 2, 2, 284, 288, 7, 44, 2, 2, 285, 288, 5, 66, 34, 2, 286,
	288, 7, 46, 2, 2, 287, 253, 3, 2, 2, 2, 287, 254, 3, 2, 2, 2, 287, 255,
	3, 2, 2, 2, 287, 256, 3, 2, 2, 2, 287, 257, 3, 2, 2, 2, 287, 258, 3, 2,
	2, 2, 287, 259, 3, 2, 2, 2, 287, 260, 3, 2, 2, 2, 287, 261, 3, 2, 2, 2,
	287, 262, 3, 2, 2, 2, 287, 263, 3, 2, 2, 2, 287, 264, 3, 2, 2, 2, 287,
	265, 3, 2, 2, 2, 287, 266, 3, 2, 2, 2, 287, 267, 3, 2, 2, 2, 287, 268,
	3, 2, 2, 2, 287, 269, 3, 2, 2, 2, 287, 270, 3, 2, 2, 2, 287, 271, 3, 2,
	2, 2, 287, 272, 3, 2, 2, 2, 287, 273, 3, 2, 2, 2, 287, 274, 3, 2, 2, 2,
	287, 275, 3, 2, 2, 2, 287, 276, 3, 2, 2, 2, 287, 277, 3, 2, 2, 2, 287,
	278, 3, 2, 2, 2, 287, 279, 3, 2, 2, 2, 287, 280, 3, 2, 2, 2, 287, 281,
	3, 2, 2, 2, 287, 282, 3, 2, 2, 2, 287, 283, 3, 2, 2, 2, 287, 284, 3, 2,
	2, 2, 287, 285, 3, 2, 2, 2, 287, 286, 3, 2, 2, 2, 288, 23, 3, 2, 2, 2,
	289, 292, 5, 22, 12, 2, 290, 292, 5, 4, 3, 2, 291, 289, 3, 2, 2, 2, 291,
	290, 3, 2, 2, 2, 292, 25, 3, 2, 2, 2, 293, 295, 5, 6, 4, 2, 294, 293, 3,
	2, 2, 2, 294, 295, 3, 2, 2, 2, 295, 296, 3, 2, 2, 2, 296, 298, 5, 24, 13,
	2, 297, 294, 3, 2, 2, 2, 298, 301, 3, 2, 2, 2, 299, 297, 3, 2, 2, 2, 299,
	300, 3, 2, 2, 2, 300, 27, 3, 2, 2, 2, 301, 299, 3, 2, 2, 2, 302, 303, 7,
	13, 2, 2, 303, 305, 5, 26, 14, 2, 304, 306, 5, 6, 4, 2, 305, 304, 3, 2,
	2, 2, 305, 306, 3, 2, 2, 2, 306, 307, 3, 2, 2, 2, 307, 308, 7, 13, 2, 2,
	308, 29, 3, 2, 2, 2, 309, 311, 5, 14, 8, 2, 310, 309, 3, 2, 2, 2, 310,
	311, 3, 2, 2, 2, 311, 312, 3, 2, 2, 2, 312, 314, 5, 88, 45, 2, 313, 315,
	5, 14, 8, 2, 314, 313, 3, 2, 2, 2, 314, 315, 3, 2, 2, 2, 315, 332, 3, 2,
	2, 2, 316, 318, 5, 14, 8, 2, 317, 316, 3, 2, 2, 2, 317, 318, 3, 2, 2, 2,
	318, 319, 3, 2, 2, 2, 319, 321, 5, 18, 10, 2, 320, 322, 5, 14, 8, 2, 321,
	320, 3, 2, 2, 2, 321, 322, 3, 2, 2, 2, 322, 332, 3, 2, 2, 2, 323, 325,
	5, 14, 8, 2, 324, 323, 3, 2, 2, 2, 324, 325, 3, 2, 2, 2, 325, 326, 3, 2,
	2, 2, 326, 328, 5, 28, 15, 2, 327, 329, 5, 14, 8, 2, 328, 327, 3, 2, 2,
	2, 328, 329, 3, 2, 2, 2, 329, 332, 3, 2, 2, 2, 330, 332, 7, 34, 2, 2, 331,
	310, 3, 2, 2, 2, 331, 317, 3, 2, 2, 2, 331, 324, 3, 2, 2, 2, 331, 330,
	3, 2, 2, 2, 332, 31, 3, 2, 2, 2, 333, 336, 5, 34, 18, 2, 334, 336, 5, 40,
	21, 2, 335, 333, 3, 2, 2, 2, 335, 334, 3, 2, 2, 2, 336, 33, 3, 2, 2, 2,
	337, 340, 5, 36, 19, 2, 338, 340, 5, 50, 26, 2, 339, 337, 3, 2, 2, 2, 339,
	338, 3, 2, 2, 2, 340, 35, 3, 2, 2, 2, 341, 343, 5, 42, 22, 2, 342, 341,
	3, 2, 2, 2, 342, 343, 3, 2, 2, 2, 343, 344, 3, 2, 2, 2, 344, 345, 5, 38,
	20, 2, 345, 37, 3, 2, 2, 2, 346, 348, 5, 14, 8, 2, 347, 346, 3, 2, 2, 2,
	347, 348, 3, 2, 2, 2, 348, 349, 3, 2, 2, 2, 349, 351, 7, 30, 2, 2, 350,
	352, 5, 50, 26, 2, 351, 350, 3, 2, 2, 2, 351, 352, 3, 2, 2, 2, 352, 353,
	3, 2, 2, 2, 353, 355, 7, 32, 2, 2, 354, 356, 5, 14, 8, 2, 355, 354, 3,
	2, 2, 2, 355, 356, 3, 2, 2, 2, 356, 359, 3, 2, 2, 2, 357, 359, 5, 72, 37,
	2, 358, 347, 3, 2, 2, 2, 358, 357, 3, 2, 2, 2, 359, 39, 3, 2, 2, 2, 360,
	361, 5, 42, 22, 2, 361, 363, 7, 28, 2, 2, 362, 364, 5, 48, 25, 2, 363,
	362, 3, 2, 2, 2, 363, 364, 3, 2, 2, 2, 364, 365, 3, 2, 2, 2, 365, 367,
	7, 29, 2, 2, 366, 368, 5, 14, 8, 2, 367, 366, 3, 2, 2, 2, 367, 368, 3,
	2, 2, 2, 368, 41, 3, 2, 2, 2, 369, 371, 5, 30, 16, 2, 370, 369, 3, 2, 2,
	2, 371, 372, 3, 2, 2, 2, 372, 370, 3, 2, 2, 2, 372, 373, 3, 2, 2, 2, 373,
	384, 3, 2, 2, 2, 374, 380, 5, 30, 16, 2, 375, 379, 5, 30, 16, 2, 376, 379,
	7, 25, 2, 2, 377, 379, 5, 14, 8, 2, 378, 375, 3, 2, 2, 2, 378, 376, 3,
	2, 2, 2, 378, 377, 3, 2, 2, 2, 379, 382, 3, 2, 2, 2, 380, 378, 3, 2, 2,
	2, 380, 381, 3, 2, 2, 2, 381, 384, 3, 2, 2, 2, 382, 380, 3, 2, 2, 2, 383,
	370, 3, 2, 2, 2, 383, 374, 3, 2, 2, 2, 384, 43, 3, 2, 2, 2, 385, 390, 5,
	34, 18, 2, 386, 387, 7, 23, 2, 2, 387, 389, 5, 34, 18, 2, 388, 386, 3,
	2, 2, 2, 389, 392, 3, 2, 2, 2, 390, 388, 3, 2, 2, 2, 390, 391, 3, 2, 2,
	2, 391, 395, 3, 2, 2, 2, 392, 390, 3, 2, 2, 2, 393, 395, 5, 78, 40, 2,
	394, 385, 3, 2, 2, 2, 394, 393, 3, 2, 2, 2, 395, 45, 3, 2, 2, 2, 396, 401,
	5, 32, 17, 2, 397, 398, 7, 23, 2, 2, 398, 400, 5, 32, 17, 2, 399, 397,
	3, 2, 2, 2, 400, 403, 3, 2, 2, 2, 401, 399, 3, 2, 2, 2, 401, 402, 3, 2,
	2, 2, 402, 404, 3, 2, 2, 2, 403, 401, 3, 2, 2, 2, 404, 405, 7, 2, 2, 3,
	405, 410, 3, 2, 2, 2, 406, 407, 5, 80, 41, 2, 407, 408, 7, 2, 2, 3, 408,
	410, 3, 2, 2, 2, 409, 396, 3, 2, 2, 2, 409, 406, 3, 2, 2, 2, 410, 47, 3,
	2, 2, 2, 411, 415, 5, 44, 23, 2, 412, 415, 5, 14, 8, 2, 413, 415, 5, 82,
	42, 2, 414, 411, 3, 2, 2, 2, 414, 412, 3, 2, 2, 2, 414, 413, 3, 2, 2, 2,
	415, 49, 3, 2, 2, 2, 416, 417, 5, 52, 27, 2, 417, 418, 7, 34, 2, 2, 418,
	421, 5, 56, 29, 2, 419, 420, 7, 28, 2, 2, 420, 422, 5, 54, 28, 2, 421,
	419, 3, 2, 2, 2, 421, 422, 3, 2, 2, 2, 422, 51, 3, 2, 2, 2, 423, 425, 5,
	14, 8, 2, 424, 423, 3, 2, 2, 2, 424, 425, 3, 2, 2, 2, 425, 426, 3, 2, 2,
	2, 426, 428, 5, 20, 11, 2, 427, 429, 5, 14, 8, 2, 428, 427, 3, 2, 2, 2,
	428, 429, 3, 2, 2, 2, 429, 439, 3, 2, 2, 2, 430, 432, 5, 14, 8, 2, 431,
	430, 3, 2, 2, 2, 431, 432, 3, 2, 2, 2, 432, 433, 3, 2, 2, 2, 433, 435,
	5, 28, 15, 2, 434, 436, 5, 14, 8, 2, 435, 434, 3, 2, 2, 2, 435, 436, 3,
	2, 2, 2, 436, 439, 3, 2, 2, 2, 437, 439, 5, 84, 43, 2, 438, 424, 3, 2,
	2, 2, 438, 431, 3, 2, 2, 2, 438, 437, 3, 2, 2, 2, 439, 53, 3, 2, 2, 2,
	440, 442, 7, 27, 2, 2, 441, 440, 3, 2, 2, 2, 442, 443, 3, 2, 2, 2, 443,
	441, 3, 2, 2, 2, 443, 444, 3, 2, 2, 2, 444, 55, 3, 2, 2, 2, 445, 447, 5,
	14, 8, 2, 446, 445, 3, 2, 2, 2, 446, 447, 3, 2, 2, 2, 447, 448, 3, 2, 2,
	2, 448, 450, 5, 20, 11, 2, 449, 451, 5, 14, 8, 2, 450, 449, 3, 2, 2, 2,
	450, 451, 3, 2, 2, 2, 451, 467, 3, 2, 2, 2, 452, 454, 5, 14, 8, 2, 453,
	452, 3, 2, 2, 2, 453, 454, 3, 2, 2, 2, 454, 455, 3, 2, 2, 2, 455, 457,
	5, 58, 30, 2, 456, 458, 5, 14, 8, 2, 457, 456, 3, 2, 2, 2, 457, 458, 3,
	2, 2, 2, 458, 467, 3, 2, 2, 2, 459, 461, 5, 14, 8, 2, 460, 459, 3, 2, 2,
	2, 460, 461, 3, 2, 2, 2, 461, 462, 3, 2, 2, 2, 462, 464, 5, 86, 44, 2,
	463, 465, 5, 14, 8, 2, 464, 463, 3, 2, 2, 2, 464, 465, 3, 2, 2, 2, 465,
	467, 3, 2, 2, 2, 466, 446, 3, 2, 2, 2, 466, 453, 3, 2, 2, 2, 466, 460,
	3, 2, 2, 2, 467, 57, 3, 2, 2, 2, 468, 475, 7, 35, 2, 2, 469, 471, 5, 6,
	4, 2, 470, 469, 3, 2, 2, 2, 470, 471, 3, 2, 2, 2, 471, 472, 3, 2, 2, 2,
	472, 474, 5, 60, 31, 2, 473, 470, 3, 2, 2, 2, 474, 477, 3, 2, 2, 2, 475,
	473, 3, 2, 2, 2, 475, 476, 3, 2, 2, 2, 476, 479, 3, 2, 2, 2, 477, 475,
	3, 2, 2, 2, 478, 480, 5, 6, 4, 2, 479, 478, 3, 2, 2, 2, 479, 480, 3, 2,
	2, 2, 480, 481, 3, 2, 2, 2, 481, 482, 7, 37, 2, 2, 482, 59, 3, 2, 2, 2,
	483, 516, 5, 108, 55, 2, 484, 516, 7, 12, 2, 2, 485, 516, 7, 13, 2, 2,
	486, 516, 7, 14, 2, 2, 487, 516, 7, 15, 2, 2, 488, 516, 7, 16, 2, 2, 489,
	516, 7, 17, 2, 2, 490, 516, 7, 18, 2, 2, 491, 516, 7, 19, 2, 2, 492, 516,
	7, 20, 2, 2, 493, 516, 7, 21, 2, 2, 494, 516, 7, 22, 2, 2, 495, 516, 7,
	23, 2, 2, 496, 516, 7, 24, 2, 2, 497, 516, 7, 25, 2, 2, 498, 516, 7, 26,
	2, 2, 499, 516, 7, 27, 2, 2, 500, 516, 7, 28, 2, 2, 501, 516, 7, 29, 2,
	2, 502, 516, 7, 30, 2, 2, 503, 516, 7, 31, 2, 2, 504, 516, 7, 32, 2, 2,
	505, 516, 7, 33, 2, 2, 506, 516, 7, 34, 2, 2, 507, 516, 7, 38, 2, 2, 508,
	516, 7, 39, 2, 2, 509, 516, 7, 40, 2, 2, 510, 516, 7, 41, 2, 2, 511, 516,
	7, 42, 2, 2, 512, 516, 7, 43, 2, 2, 513, 516, 7, 44, 2, 2, 514, 516, 7,
	46, 2, 2, 515, 483, 3, 2, 2, 2, 515, 484, 3, 2, 2, 2, 515, 485, 3, 2, 2,
	2, 515, 486, 3, 2, 2, 2, 515, 487, 3, 2, 2, 2, 515, 488, 3, 2, 2, 2, 515,
	489, 3, 2, 2, 2, 515, 490, 3, 2, 2, 2, 515, 491, 3, 2, 2, 2, 515, 492,
	3, 2, 2, 2, 515, 493, 3, 2, 2, 2, 515, 494, 3, 2, 2, 2, 515, 495, 3, 2,
	2, 2, 515, 496, 3, 2, 2, 2, 515, 497, 3, 2, 2, 2, 515, 498, 3, 2, 2, 2,
	515, 499, 3, 2, 2, 2, 515, 500, 3, 2, 2, 2, 515, 501, 3, 2, 2, 2, 515,
	502, 3, 2, 2, 2, 515, 503, 3, 2, 2, 2, 515, 504, 3, 2, 2, 2, 515, 505,
	3, 2, 2, 2, 515, 506, 3, 2, 2, 2, 515, 507, 3, 2, 2, 2, 515, 508, 3, 2,
	2, 2, 515, 509, 3, 2, 2, 2, 515, 510, 3, 2, 2, 2, 515, 511, 3, 2, 2, 2,
	515, 512, 3, 2, 2, 2, 515, 513, 3, 2, 2, 2, 515, 514, 3, 2, 2, 2, 516,
	61, 3, 2, 2, 2, 517, 518, 9, 2, 2, 2, 518, 63, 3, 2, 2, 2, 519, 520, 5,
	62, 32, 2, 520, 65, 3, 2, 2, 2, 521, 522, 5, 62, 32, 2, 522, 67, 3, 2,
	2, 2, 523, 528, 7, 36, 2, 2, 524, 529, 7, 3, 2, 2, 525, 529, 5, 62, 32,
	2, 526, 529, 7, 6, 2, 2, 527, 529, 7, 9, 2, 2, 528, 524, 3, 2, 2, 2, 528,
	525, 3, 2, 2, 2, 528, 526, 3, 2, 2, 2, 528, 527, 3, 2, 2, 2, 529, 69, 3,
	2, 2, 2, 530, 532, 5, 104, 53, 2, 531, 530, 3, 2, 2, 2, 532, 533, 3, 2,
	2, 2, 533, 531, 3, 2, 2, 2, 533, 534, 3, 2, 2, 2, 534, 535, 3, 2, 2, 2,
	535, 537, 5, 102, 52, 2, 536, 538, 5, 104, 53, 2, 537, 536, 3, 2, 2, 2,
	538, 539, 3, 2, 2, 2, 539, 537, 3, 2, 2, 2, 539, 540, 3, 2, 2, 2, 540,
	71, 3, 2, 2, 2, 541, 543, 5, 14, 8, 2, 542, 541, 3, 2, 2, 2, 542, 543,
	3, 2, 2, 2, 543, 544, 3, 2, 2, 2, 544, 545, 7, 30, 2, 2, 545, 546, 5, 74,
	38, 2, 546, 547, 5, 50, 26, 2, 547, 549, 7, 32, 2, 2, 548, 550, 5, 14,
	8, 2, 549, 548, 3, 2, 2, 2, 549, 550, 3, 2, 2, 2, 550, 73, 3, 2, 2, 2,
	551, 552, 5, 76, 39, 2, 552, 553, 7, 28, 2, 2, 553, 75, 3, 2, 2, 2, 554,
	557, 5, 14, 8, 2, 555, 557, 7, 23, 2, 2, 556, 554, 3, 2, 2, 2, 556, 555,
	3, 2, 2, 2, 557, 560, 3, 2, 2, 2, 558, 556, 3, 2, 2, 2, 558, 559, 3, 2,
	2, 2, 559, 561, 3, 2, 2, 2, 560, 558, 3, 2, 2, 2, 561, 562, 7, 34, 2, 2,
	562, 573, 5, 56, 29, 2, 563, 565, 7, 23, 2, 2, 564, 566, 5, 14, 8, 2, 565,
	564, 3, 2, 2, 2, 565, 566, 3, 2, 2, 2, 566, 569, 3, 2, 2, 2, 567, 568,
	7, 34, 2, 2, 568, 570, 5, 56, 29, 2, 569, 567, 3, 2, 2, 2, 569, 570, 3,
	2, 2, 2, 570, 572, 3, 2, 2, 2, 571, 563, 3, 2, 2, 2, 572, 575, 3, 2, 2,
	2, 573, 571, 3, 2, 2, 2, 573, 574, 3, 2, 2, 2, 574, 77, 3, 2, 2, 2, 575,
	573, 3, 2, 2, 2, 576, 578, 5, 14, 8, 2, 577, 576, 3, 2, 2, 2, 577, 578,
	3, 2, 2, 2, 578, 579, 3, 2, 2, 2, 579, 581, 7, 23, 2, 2, 580, 577, 3, 2,
	2, 2, 581, 584, 3, 2, 2, 2, 582, 580, 3, 2, 2, 2, 582, 583, 3, 2, 2, 2,
	583, 585, 3, 2, 2, 2, 584, 582, 3, 2, 2, 2, 585, 593, 5, 34, 18, 2, 586,
	589, 7, 23, 2, 2, 587, 590, 5, 34, 18, 2, 588, 590, 5, 14, 8, 2, 589, 587,
	3, 2, 2, 2, 589, 588, 3, 2, 2, 2, 589, 590, 3, 2, 2, 2, 590, 592, 3, 2,
	2, 2, 591, 586, 3, 2, 2, 2, 592, 595, 3, 2, 2, 2, 593, 591, 3, 2, 2, 2,
	593, 594, 3, 2, 2, 2, 594, 79, 3, 2, 2, 2, 595, 593, 3, 2, 2, 2, 596, 598,
	5, 14, 8, 2, 597, 596, 3, 2, 2, 2, 597, 598, 3, 2, 2, 2, 598, 599, 3, 2,
	2, 2, 599, 601, 7, 23, 2, 2, 600, 597, 3, 2, 2, 2, 601, 604, 3, 2, 2, 2,
	602, 600, 3, 2, 2, 2, 602, 603, 3, 2, 2, 2, 603, 605, 3, 2, 2, 2, 604,
	602, 3, 2, 2, 2, 605, 613, 5, 32, 17, 2, 606, 609, 7, 23, 2, 2, 607, 610,
	5, 32, 17, 2, 608, 610, 5, 14, 8, 2, 609, 607, 3, 2, 2, 2, 609, 608, 3,
	2, 2, 2, 609, 610, 3, 2, 2, 2, 610, 612, 3, 2, 2, 2, 611, 606, 3, 2, 2,
	2, 612, 615, 3, 2, 2, 2, 613, 611, 3, 2, 2, 2, 613, 614, 3, 2, 2, 2, 614,
	81, 3, 2, 2, 2, 615, 613, 3, 2, 2, 2, 616, 618, 5, 14, 8, 2, 617, 616,
	3, 2, 2, 2, 617, 618, 3, 2, 2, 2, 618, 619, 3, 2, 2, 2, 619, 621, 7, 23,
	2, 2, 620, 617, 3, 2, 2, 2, 621, 622, 3, 2, 2, 2, 622, 620, 3, 2, 2, 2,
	622, 623, 3, 2, 2, 2, 623, 625, 3, 2, 2, 2, 624, 626, 5, 14, 8, 2, 625,
	624, 3, 2, 2, 2, 625, 626, 3, 2, 2, 2, 626, 83, 3, 2, 2, 2, 627, 632, 5,
	30, 16, 2, 628, 629, 7, 25, 2, 2, 629, 631, 5, 30, 16, 2, 630, 628, 3,
	2, 2, 2, 631, 634, 3, 2, 2, 2, 632, 630, 3, 2, 2, 2, 632, 633, 3, 2, 2,
	2, 633, 85, 3, 2, 2, 2, 634, 632, 3, 2, 2, 2, 635, 640, 5, 18, 10, 2, 636,
	637, 7, 25, 2, 2, 637, 639, 5, 18, 10, 2, 638, 636, 3, 2, 2, 2, 639, 642,
	3, 2, 2, 2, 640, 638, 3, 2, 2, 2, 640, 641, 3, 2, 2, 2, 641, 87, 3, 2,
	2, 2, 642, 640, 3, 2, 2, 2, 643, 644, 7, 31, 2, 2, 644, 645, 7, 33, 2,
	2, 645, 646, 5, 90, 46, 2, 646, 647, 7, 33, 2, 2, 647, 648, 5, 92, 47,
	2, 648, 649, 7, 33, 2, 2, 649, 650, 5, 98, 50, 2, 650, 651, 7, 33, 2, 2,
	651, 652, 7, 31, 2, 2, 652, 89, 3, 2, 2, 2, 653, 654, 5, 94, 48, 2, 654,
	91, 3, 2, 2, 2, 655, 656, 5, 94, 48, 2, 656, 93, 3, 2, 2, 2, 657, 659,
	5, 96, 49, 2, 658, 657, 3, 2, 2, 2, 659, 660, 3, 2, 2, 2, 660, 658, 3,
	2, 2, 2, 660, 661, 3, 2, 2, 2, 661, 95, 3, 2, 2, 2, 662, 682, 5, 108, 55,
	2, 663, 682, 7, 12, 2, 2, 664, 682, 7, 14, 2, 2, 665, 682, 7, 15, 2, 2,
	666, 682, 7, 16, 2, 2, 667, 682, 7, 17, 2, 2, 668, 682, 7, 18, 2, 2, 669,
	682, 7, 21, 2, 2, 670, 682, 7, 22, 2, 2, 671, 682, 7, 24, 2, 2, 672, 682,
	7, 27, 2, 2, 673, 682, 7, 36, 2, 2, 674, 682, 7, 38, 2, 2, 675, 682, 7,
	39, 2, 2, 676, 682, 7, 40, 2, 2, 677, 682, 7, 41, 2, 2, 678, 682, 7, 42,
	2, 2, 679, 682, 7, 43, 2, 2, 680, 682, 7, 44, 2, 2, 681, 662, 3, 2, 2,
	2, 681, 663, 3, 2, 2, 2, 681, 664, 3, 2, 2, 2, 681, 665, 3, 2, 2, 2, 681,
	666, 3, 2, 2, 2, 681, 667, 3, 2, 2, 2, 681, 668, 3, 2, 2, 2, 681, 669,
	3, 2, 2, 2, 681, 670, 3, 2, 2, 2, 681, 671, 3, 2, 2, 2, 681, 672, 3, 2,
	2, 2, 681, 673, 3, 2, 2, 2, 681, 674, 3, 2, 2, 2, 681, 675, 3, 2, 2, 2,
	681, 676, 3, 2, 2, 2, 681, 677, 3, 2, 2, 2, 681, 678, 3, 2, 2, 2, 681,
	679, 3, 2, 2, 2, 681, 680, 3, 2, 2, 2, 682, 97, 3, 2, 2, 2, 683, 685, 5,
	100, 51, 2, 684, 683, 3, 2, 2, 2, 685, 686, 3, 2, 2, 2, 686, 684, 3, 2,
	2, 2, 686, 687, 3, 2, 2, 2, 687, 99, 3, 2, 2, 2, 688, 722, 5, 108, 55,
	2, 689, 722, 7, 12, 2, 2, 690, 722, 7, 13, 2, 2, 691, 722, 7, 14, 2, 2,
	692, 722, 7, 15, 2, 2, 693, 722, 7, 16, 2, 2, 694, 722, 7, 17, 2, 2, 695,
	722, 7, 18, 2, 2, 696, 722, 7, 19, 2, 2, 697, 722, 7, 20, 2, 2, 698, 722,
	7, 21, 2, 2, 699, 722, 7, 22, 2, 2, 700, 722, 7, 23, 2, 2, 701, 722, 7,
	24, 2, 2, 702, 722, 7, 25, 2, 2, 703, 722, 7, 26, 2, 2, 704, 722, 7, 27,
	2, 2, 705, 722, 7, 28, 2, 2, 706, 722, 7, 29, 2, 2, 707, 722, 7, 30, 2,
	2, 708, 722, 7, 31, 2, 2, 709, 722, 7, 32, 2, 2, 710, 722, 7, 34, 2, 2,
	711, 722, 7, 35, 2, 2, 712, 722, 7, 36, 2, 2, 713, 722, 7, 37, 2, 2, 714,
	722, 7, 38, 2, 2, 715, 722, 7, 39, 2, 2, 716, 722, 7, 40, 2, 2, 717, 722,
	7, 41, 2, 2, 718, 722, 7, 42, 2, 2, 719, 722, 7, 43, 2, 2, 720, 722, 7,
	44, 2, 2, 721, 688, 3, 2, 2, 2, 721, 689, 3, 2, 2, 2, 721, 690, 3, 2, 2,
	2, 721, 691, 3, 2, 2, 2, 721, 692, 3, 2, 2, 2, 721, 693, 3, 2, 2, 2, 721,
	694, 3, 2, 2, 2, 721, 695, 3, 2, 2, 2, 721, 696, 3, 2, 2, 2, 721, 697,
	3, 2, 2, 2, 721, 698, 3, 2, 2, 2, 721, 699, 3, 2, 2, 2, 721, 700, 3, 2,
	2, 2, 721, 701, 3, 2, 2, 2, 721, 702, 3, 2, 2, 2, 721, 703, 3, 2, 2, 2,
	721, 704, 3, 2, 2, 2, 721, 705, 3, 2, 2, 2, 721, 706, 3, 2, 2, 2, 721,
	707, 3, 2, 2, 2, 721, 708, 3, 2, 2, 2, 721, 709, 3, 2, 2, 2, 721, 710,
	3, 2, 2, 2, 721, 711, 3, 2, 2, 2, 721, 712, 3, 2, 2, 2, 721, 713, 3, 2,
	2, 2, 721, 714, 3, 2, 2, 2, 721, 715, 3, 2, 2, 2, 721, 716, 3, 2, 2, 2,
	721, 717, 3, 2, 2, 2, 721, 718, 3, 2, 2, 2, 721, 719, 3, 2, 2, 2, 721,
	720, 3, 2, 2, 2, 722, 101, 3, 2, 2, 2, 723, 724, 7, 9, 2, 2, 724, 725,
	7, 6, 2, 2, 725, 103, 3, 2, 2, 2, 726, 727, 9, 3, 2, 2, 727, 105, 3, 2,
	2, 2, 728, 764, 5, 108, 55, 2, 729, 764, 7, 12, 2, 2, 730, 764, 7, 13,
	2, 2, 731, 764, 7, 14, 2, 2, 732, 764, 7, 15, 2, 2, 733, 764, 7, 16, 2,
	2, 734, 764, 7, 17, 2, 2, 735, 764, 7, 18, 2, 2, 736, 764, 7, 19, 2, 2,
	737, 764, 7, 20, 2, 2, 738, 764, 7, 21, 2, 2, 739, 764, 7, 22, 2, 2, 740,
	764, 7, 23, 2, 2, 741, 764, 7, 24, 2, 2, 742, 764, 7, 25, 2, 2, 743, 764,
	7, 26, 2, 2, 744, 764, 7, 27, 2, 2, 745, 764, 7, 28, 2, 2, 746, 764, 7,
	29, 2, 2, 747, 764, 7, 30, 2, 2, 748, 764, 7, 31, 2, 2, 749, 764, 7, 32,
	2, 2, 750, 764, 7, 33, 2, 2, 751, 764, 7, 34, 2, 2, 752, 764, 7, 35, 2,
	2, 753, 764, 7, 36, 2, 2, 754, 764, 7, 37, 2, 2, 755, 764, 7, 38, 2, 2,
	756, 764, 7, 39, 2, 2, 757, 764, 7, 40, 2, 2, 758, 764, 7, 41, 2, 2, 759,
	764, 7, 42, 2, 2, 760, 764, 7, 43, 2, 2, 761, 764, 7, 44, 2, 2, 762, 764,
	7, 46, 2, 2, 763, 728, 3, 2, 2, 2, 763, 729, 3, 2, 2, 2, 763, 730, 3, 2,
	2, 2, 763, 731, 3, 2, 2, 2, 763, 732, 3, 2, 2, 2, 763, 733, 3, 2, 2, 2,
	763, 734, 3, 2, 2, 2, 763, 735, 3, 2, 2, 2, 763, 736, 3, 2, 2, 2, 763,
	737, 3, 2, 2, 2, 763, 738, 3, 2, 2, 2, 763, 739, 3, 2, 2, 2, 763, 740,
	3, 2, 2, 2, 763, 741, 3, 2, 2, 2, 763, 742, 3, 2, 2, 2, 763, 743, 3, 2,
	2, 2, 763, 744, 3, 2, 2, 2, 763, 745, 3, 2, 2, 2, 763, 746, 3, 2, 2, 2,
	763, 747, 3, 2, 2, 2, 763, 748, 3, 2, 2, 2, 763, 749, 3, 2, 2, 2, 763,
	750, 3, 2, 2, 2, 763, 751, 3, 2, 2, 2, 763, 752, 3, 2, 2, 2, 763, 753,
	3, 2, 2, 2, 763, 754, 3, 2, 2, 2, 763, 755, 3, 2, 2, 2, 763, 756, 3, 2,
	2, 2, 763, 757, 3, 2, 2, 2, 763, 758, 3, 2, 2, 2, 763, 759, 3, 2, 2, 2,
	763, 760, 3, 2, 2, 2, 763, 761, 3, 2, 2, 2, 763, 762, 3, 2, 2, 2, 764,
	107, 3, 2, 2, 2, 765, 766, 9, 4, 2, 2, 766, 109, 3, 2, 2, 2, 99, 112, 117,
	122, 126, 131, 134, 169, 174, 178, 183, 187, 192, 197, 200, 203, 227, 232,
	237, 243, 247, 251, 287, 291, 294, 299, 305, 310, 314, 317, 321, 324, 328,
	331, 335, 339, 342, 347, 351, 355, 358, 363, 367, 372, 378, 380, 383, 390,
	394, 401, 409, 414, 421, 424, 428, 431, 435, 438, 443, 446, 450, 453, 457,
	460, 464, 466, 470, 475, 479, 515, 528, 533, 539, 542, 549, 556, 558, 565,
	569, 573, 577, 582, 589, 593, 597, 602, 609, 613, 617, 622, 625, 632, 640,
	660, 681, 686, 721, 763,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'\u0000'", "", "'\t'", "'\n'", "'\u000B'", "'\u000C'", "'\r'", "",
	"' '", "'!'", "'\"'", "'#'", "'$'", "'%'", "'&'", "'''", "'('", "')'",
	"'*'", "'+'", "','", "'-'", "'.'", "'/'", "", "':'", "';'", "'<'", "'='",
	"'>'", "'?'", "'@'", "'['", "'\\'", "']'", "'^'", "'_'", "'`'", "'{'",
	"'|'", "'}'", "'~'", "'\u007F'",
}
var symbolicNames = []string{
	"", "U_00", "U_01_08", "TAB", "LF", "U_0B", "U_0C", "CR", "U_0E_1F", "SP",
	"Exclamation", "DQuote", "Hash", "Dollar", "Percent", "Ampersand", "SQuote",
	"LParens", "RParens", "Asterisk", "Plus", "Comma", "Minus", "Period", "Slash",
	"Digit", "Colon", "Semicolon", "Less", "Equal", "Greater", "Question",
	"At", "LBracket", "Backslash", "RBracket", "Caret", "Underscore", "Backtick",
	"LCurly", "Pipe", "RCurly", "Tilde", "Delete", "UTF8NonAscii", "A", "B",
	"C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q",
	"R", "S", "T", "U", "V", "W", "X", "Y", "Z",
}

var ruleNames = []string{
	"quotedChar", "quotedPair", "fws", "ctext", "ccontent", "comment", "cfws",
	"atext", "atom", "dotAtom", "qtext", "quotedContent", "quotedValue", "quotedString",
	"word", "address", "mailbox", "nameAddr", "angleAddr", "group", "displayName",
	"mailboxList", "addressList", "groupList", "addrSpec", "localPart", "port",
	"domain", "domainLiteral", "dtext", "obsNoWSCTL", "obsCtext", "obsQtext",
	"obsQP", "obsFWS", "obsAngleAddr", "obsRoute", "obsDomainList", "obsMboxList",
	"obsAddrList", "obsGroupList", "obsLocalPart", "obsDomain", "encodedWord",
	"charset", "encoding", "token", "tokenChar", "encodedText", "encodedChar",
	"crlf", "wsp", "vchar", "alpha",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type RFC5322Parser struct {
	*antlr.BaseParser
}

func NewRFC5322Parser(input antlr.TokenStream) *RFC5322Parser {
	this := new(RFC5322Parser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "RFC5322Parser.g4"

	return this
}

// RFC5322Parser tokens.
const (
	RFC5322ParserEOF          = antlr.TokenEOF
	RFC5322ParserU_00         = 1
	RFC5322ParserU_01_08      = 2
	RFC5322ParserTAB          = 3
	RFC5322ParserLF           = 4
	RFC5322ParserU_0B         = 5
	RFC5322ParserU_0C         = 6
	RFC5322ParserCR           = 7
	RFC5322ParserU_0E_1F      = 8
	RFC5322ParserSP           = 9
	RFC5322ParserExclamation  = 10
	RFC5322ParserDQuote       = 11
	RFC5322ParserHash         = 12
	RFC5322ParserDollar       = 13
	RFC5322ParserPercent      = 14
	RFC5322ParserAmpersand    = 15
	RFC5322ParserSQuote       = 16
	RFC5322ParserLParens      = 17
	RFC5322ParserRParens      = 18
	RFC5322ParserAsterisk     = 19
	RFC5322ParserPlus         = 20
	RFC5322ParserComma        = 21
	RFC5322ParserMinus        = 22
	RFC5322ParserPeriod       = 23
	RFC5322ParserSlash        = 24
	RFC5322ParserDigit        = 25
	RFC5322ParserColon        = 26
	RFC5322ParserSemicolon    = 27
	RFC5322ParserLess         = 28
	RFC5322ParserEqual        = 29
	RFC5322ParserGreater      = 30
	RFC5322ParserQuestion     = 31
	RFC5322ParserAt           = 32
	RFC5322ParserLBracket     = 33
	RFC5322ParserBackslash    = 34
	RFC5322ParserRBracket     = 35
	RFC5322ParserCaret        = 36
	RFC5322ParserUnderscore   = 37
	RFC5322ParserBacktick     = 38
	RFC5322ParserLCurly       = 39
	RFC5322ParserPipe         = 40
	RFC5322ParserRCurly       = 41
	RFC5322ParserTilde        = 42
	RFC5322ParserDelete       = 43
	RFC5322ParserUTF8NonAscii = 44
	RFC5322ParserA            = 45
	RFC5322ParserB            = 46
	RFC5322ParserC            = 47
	RFC5322ParserD            = 48
	RFC5322ParserE            = 49
	RFC5322ParserF            = 50
	RFC5322ParserG            = 51
	RFC5322ParserH            = 52
	RFC5322ParserI            = 53
	RFC5322ParserJ            = 54
	RFC5322ParserK            = 55
	RFC5322ParserL            = 56
	RFC5322ParserM            = 57
	RFC5322ParserN            = 58
	RFC5322ParserO            = 59
	RFC5322ParserP            = 60
	RFC5322ParserQ            = 61
	RFC5322ParserR            = 62
	RFC5322ParserS            = 63
	RFC5322ParserT            = 64
	RFC5322ParserU            = 65
	RFC5322ParserV            = 66
	RFC5322ParserW            = 67
	RFC5322ParserX            = 68
	RFC5322ParserY            = 69
	RFC5322ParserZ            = 70
)

// RFC5322Parser rules.
const (
	RFC5322ParserRULE_quotedChar    = 0
	RFC5322ParserRULE_quotedPair    = 1
	RFC5322ParserRULE_fws           = 2
	RFC5322ParserRULE_ctext         = 3
	RFC5322ParserRULE_ccontent      = 4
	RFC5322ParserRULE_comment       = 5
	RFC5322ParserRULE_cfws          = 6
	RFC5322ParserRULE_atext         = 7
	RFC5322ParserRULE_atom          = 8
	RFC5322ParserRULE_dotAtom       = 9
	RFC5322ParserRULE_qtext         = 10
	RFC5322ParserRULE_quotedContent = 11
	RFC5322ParserRULE_quotedValue   = 12
	RFC5322ParserRULE_quotedString  = 13
	RFC5322ParserRULE_word          = 14
	RFC5322ParserRULE_address       = 15
	RFC5322ParserRULE_mailbox       = 16
	RFC5322ParserRULE_nameAddr      = 17
	RFC5322ParserRULE_angleAddr     = 18
	RFC5322ParserRULE_group         = 19
	RFC5322ParserRULE_displayName   = 20
	RFC5322ParserRULE_mailboxList   = 21
	RFC5322ParserRULE_addressList   = 22
	RFC5322ParserRULE_groupList     = 23
	RFC5322ParserRULE_addrSpec      = 24
	RFC5322ParserRULE_localPart     = 25
	RFC5322ParserRULE_port          = 26
	RFC5322ParserRULE_domain        = 27
	RFC5322ParserRULE_domainLiteral = 28
	RFC5322ParserRULE_dtext         = 29
	RFC5322ParserRULE_obsNoWSCTL    = 30
	RFC5322ParserRULE_obsCtext      = 31
	RFC5322ParserRULE_obsQtext      = 32
	RFC5322ParserRULE_obsQP         = 33
	RFC5322ParserRULE_obsFWS        = 34
	RFC5322ParserRULE_obsAngleAddr  = 35
	RFC5322ParserRULE_obsRoute      = 36
	RFC5322ParserRULE_obsDomainList = 37
	RFC5322ParserRULE_obsMboxList   = 38
	RFC5322ParserRULE_obsAddrList   = 39
	RFC5322ParserRULE_obsGroupList  = 40
	RFC5322ParserRULE_obsLocalPart  = 41
	RFC5322ParserRULE_obsDomain     = 42
	RFC5322ParserRULE_encodedWord   = 43
	RFC5322ParserRULE_charset       = 44
	RFC5322ParserRULE_encoding      = 45
	RFC5322ParserRULE_token         = 46
	RFC5322ParserRULE_tokenChar     = 47
	RFC5322ParserRULE_encodedText   = 48
	RFC5322ParserRULE_encodedChar   = 49
	RFC5322ParserRULE_crlf          = 50
	RFC5322ParserRULE_wsp           = 51
	RFC5322ParserRULE_vchar         = 52
	RFC5322ParserRULE_alpha         = 53
)

// IQuotedCharContext is an interface to support dynamic dispatch.
type IQuotedCharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuotedCharContext differentiates from other interfaces.
	IsQuotedCharContext()
}

type QuotedCharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedCharContext() *QuotedCharContext {
	var p = new(QuotedCharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_quotedChar
	return p
}

func (*QuotedCharContext) IsQuotedCharContext() {}

func NewQuotedCharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedCharContext {
	var p = new(QuotedCharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_quotedChar

	return p
}

func (s *QuotedCharContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedCharContext) Vchar() IVcharContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVcharContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVcharContext)
}

func (s *QuotedCharContext) Wsp() IWspContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWspContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWspContext)
}

func (s *QuotedCharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedCharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedCharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterQuotedChar(s)
	}
}

func (s *QuotedCharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitQuotedChar(s)
	}
}

func (p *RFC5322Parser) QuotedChar() (localctx IQuotedCharContext) {
	localctx = NewQuotedCharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, RFC5322ParserRULE_quotedChar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(110)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserExclamation, RFC5322ParserDQuote, RFC5322ParserHash, RFC5322ParserDollar, RFC5322ParserPercent, RFC5322ParserAmpersand, RFC5322ParserSQuote, RFC5322ParserLParens, RFC5322ParserRParens, RFC5322ParserAsterisk, RFC5322ParserPlus, RFC5322ParserComma, RFC5322ParserMinus, RFC5322ParserPeriod, RFC5322ParserSlash, RFC5322ParserDigit, RFC5322ParserColon, RFC5322ParserSemicolon, RFC5322ParserLess, RFC5322ParserEqual, RFC5322ParserGreater, RFC5322ParserQuestion, RFC5322ParserAt, RFC5322ParserLBracket, RFC5322ParserBackslash, RFC5322ParserRBracket, RFC5322ParserCaret, RFC5322ParserUnderscore, RFC5322ParserBacktick, RFC5322ParserLCurly, RFC5322ParserPipe, RFC5322ParserRCurly, RFC5322ParserTilde, RFC5322ParserUTF8NonAscii, RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(108)
			p.Vchar()
		}

	case RFC5322ParserTAB, RFC5322ParserSP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(109)
			p.Wsp()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQuotedPairContext is an interface to support dynamic dispatch.
type IQuotedPairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuotedPairContext differentiates from other interfaces.
	IsQuotedPairContext()
}

type QuotedPairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedPairContext() *QuotedPairContext {
	var p = new(QuotedPairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_quotedPair
	return p
}

func (*QuotedPairContext) IsQuotedPairContext() {}

func NewQuotedPairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedPairContext {
	var p = new(QuotedPairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_quotedPair

	return p
}

func (s *QuotedPairContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedPairContext) Backslash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBackslash, 0)
}

func (s *QuotedPairContext) QuotedChar() IQuotedCharContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuotedCharContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuotedCharContext)
}

func (s *QuotedPairContext) ObsQP() IObsQPContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsQPContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsQPContext)
}

func (s *QuotedPairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedPairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedPairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterQuotedPair(s)
	}
}

func (s *QuotedPairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitQuotedPair(s)
	}
}

func (p *RFC5322Parser) QuotedPair() (localctx IQuotedPairContext) {
	localctx = NewQuotedPairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, RFC5322ParserRULE_quotedPair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(115)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(112)
			p.Match(RFC5322ParserBackslash)
		}
		{
			p.SetState(113)
			p.QuotedChar()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(114)
			p.ObsQP()
		}

	}

	return localctx
}

// IFwsContext is an interface to support dynamic dispatch.
type IFwsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFwsContext differentiates from other interfaces.
	IsFwsContext()
}

type FwsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFwsContext() *FwsContext {
	var p = new(FwsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_fws
	return p
}

func (*FwsContext) IsFwsContext() {}

func NewFwsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FwsContext {
	var p = new(FwsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_fws

	return p
}

func (s *FwsContext) GetParser() antlr.Parser { return s.parser }

func (s *FwsContext) Crlf() ICrlfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrlfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *FwsContext) AllWsp() []IWspContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWspContext)(nil)).Elem())
	var tst = make([]IWspContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWspContext)
		}
	}

	return tst
}

func (s *FwsContext) Wsp(i int) IWspContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWspContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWspContext)
}

func (s *FwsContext) ObsFWS() IObsFWSContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsFWSContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsFWSContext)
}

func (s *FwsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FwsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FwsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterFws(s)
	}
}

func (s *FwsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitFws(s)
	}
}

func (p *RFC5322Parser) Fws() (localctx IFwsContext) {
	localctx = NewFwsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, RFC5322ParserRULE_fws)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(132)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(124)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
			p.SetState(120)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == RFC5322ParserTAB || _la == RFC5322ParserSP {
				{
					p.SetState(117)
					p.Wsp()
				}

				p.SetState(122)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(123)
				p.Crlf()
			}

		}
		p.SetState(127)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(126)
					p.Wsp()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(129)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(131)
			p.ObsFWS()
		}

	}

	return localctx
}

// ICtextContext is an interface to support dynamic dispatch.
type ICtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCtextContext differentiates from other interfaces.
	IsCtextContext()
}

type CtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCtextContext() *CtextContext {
	var p = new(CtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_ctext
	return p
}

func (*CtextContext) IsCtextContext() {}

func NewCtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CtextContext {
	var p = new(CtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_ctext

	return p
}

func (s *CtextContext) GetParser() antlr.Parser { return s.parser }

func (s *CtextContext) Alpha() IAlphaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *CtextContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *CtextContext) DQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDQuote, 0)
}

func (s *CtextContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *CtextContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *CtextContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *CtextContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *CtextContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *CtextContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *CtextContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *CtextContext) Comma() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, 0)
}

func (s *CtextContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *CtextContext) Period() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, 0)
}

func (s *CtextContext) Slash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSlash, 0)
}

func (s *CtextContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *CtextContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *CtextContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSemicolon, 0)
}

func (s *CtextContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *CtextContext) Equal() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, 0)
}

func (s *CtextContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *CtextContext) Question() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQuestion, 0)
}

func (s *CtextContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *CtextContext) LBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLBracket, 0)
}

func (s *CtextContext) RBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRBracket, 0)
}

func (s *CtextContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *CtextContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *CtextContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *CtextContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *CtextContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *CtextContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *CtextContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *CtextContext) ObsCtext() IObsCtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsCtextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsCtextContext)
}

func (s *CtextContext) UTF8NonAscii() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUTF8NonAscii, 0)
}

func (s *CtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterCtext(s)
	}
}

func (s *CtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitCtext(s)
	}
}

func (p *RFC5322Parser) Ctext() (localctx ICtextContext) {
	localctx = NewCtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, RFC5322ParserRULE_ctext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(167)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(134)
			p.Alpha()
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(135)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserDQuote:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(136)
			p.Match(RFC5322ParserDQuote)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(137)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(138)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(139)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(140)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(141)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(142)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(143)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserComma:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(144)
			p.Match(RFC5322ParserComma)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(145)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserPeriod:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(146)
			p.Match(RFC5322ParserPeriod)
		}

	case RFC5322ParserSlash:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(147)
			p.Match(RFC5322ParserSlash)
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(148)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserColon:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(149)
			p.Match(RFC5322ParserColon)
		}

	case RFC5322ParserSemicolon:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(150)
			p.Match(RFC5322ParserSemicolon)
		}

	case RFC5322ParserLess:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(151)
			p.Match(RFC5322ParserLess)
		}

	case RFC5322ParserEqual:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(152)
			p.Match(RFC5322ParserEqual)
		}

	case RFC5322ParserGreater:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(153)
			p.Match(RFC5322ParserGreater)
		}

	case RFC5322ParserQuestion:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(154)
			p.Match(RFC5322ParserQuestion)
		}

	case RFC5322ParserAt:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(155)
			p.Match(RFC5322ParserAt)
		}

	case RFC5322ParserLBracket:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(156)
			p.Match(RFC5322ParserLBracket)
		}

	case RFC5322ParserRBracket:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(157)
			p.Match(RFC5322ParserRBracket)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(158)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(159)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(160)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(161)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(162)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(163)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(164)
			p.Match(RFC5322ParserTilde)
		}

	case RFC5322ParserU_01_08, RFC5322ParserU_0B, RFC5322ParserU_0C, RFC5322ParserU_0E_1F, RFC5322ParserDelete:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(165)
			p.ObsCtext()
		}

	case RFC5322ParserUTF8NonAscii:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(166)
			p.Match(RFC5322ParserUTF8NonAscii)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICcontentContext is an interface to support dynamic dispatch.
type ICcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCcontentContext differentiates from other interfaces.
	IsCcontentContext()
}

type CcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCcontentContext() *CcontentContext {
	var p = new(CcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_ccontent
	return p
}

func (*CcontentContext) IsCcontentContext() {}

func NewCcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CcontentContext {
	var p = new(CcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_ccontent

	return p
}

func (s *CcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *CcontentContext) Ctext() ICtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICtextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICtextContext)
}

func (s *CcontentContext) QuotedPair() IQuotedPairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuotedPairContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuotedPairContext)
}

func (s *CcontentContext) Comment() ICommentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterCcontent(s)
	}
}

func (s *CcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitCcontent(s)
	}
}

func (p *RFC5322Parser) Ccontent() (localctx ICcontentContext) {
	localctx = NewCcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, RFC5322ParserRULE_ccontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(172)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserU_01_08, RFC5322ParserU_0B, RFC5322ParserU_0C, RFC5322ParserU_0E_1F, RFC5322ParserExclamation, RFC5322ParserDQuote, RFC5322ParserHash, RFC5322ParserDollar, RFC5322ParserPercent, RFC5322ParserAmpersand, RFC5322ParserSQuote, RFC5322ParserAsterisk, RFC5322ParserPlus, RFC5322ParserComma, RFC5322ParserMinus, RFC5322ParserPeriod, RFC5322ParserSlash, RFC5322ParserDigit, RFC5322ParserColon, RFC5322ParserSemicolon, RFC5322ParserLess, RFC5322ParserEqual, RFC5322ParserGreater, RFC5322ParserQuestion, RFC5322ParserAt, RFC5322ParserLBracket, RFC5322ParserRBracket, RFC5322ParserCaret, RFC5322ParserUnderscore, RFC5322ParserBacktick, RFC5322ParserLCurly, RFC5322ParserPipe, RFC5322ParserRCurly, RFC5322ParserTilde, RFC5322ParserDelete, RFC5322ParserUTF8NonAscii, RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(169)
			p.Ctext()
		}

	case RFC5322ParserBackslash:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(170)
			p.QuotedPair()
		}

	case RFC5322ParserLParens:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(171)
			p.Comment()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_comment
	return p
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) LParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLParens, 0)
}

func (s *CommentContext) RParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRParens, 0)
}

func (s *CommentContext) AllCcontent() []ICcontentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICcontentContext)(nil)).Elem())
	var tst = make([]ICcontentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICcontentContext)
		}
	}

	return tst
}

func (s *CommentContext) Ccontent(i int) ICcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICcontentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICcontentContext)
}

func (s *CommentContext) AllFws() []IFwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFwsContext)(nil)).Elem())
	var tst = make([]IFwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFwsContext)
		}
	}

	return tst
}

func (s *CommentContext) Fws(i int) IFwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitComment(s)
	}
}

func (p *RFC5322Parser) Comment() (localctx ICommentContext) {
	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, RFC5322ParserRULE_comment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(174)
		p.Match(RFC5322ParserLParens)
	}
	p.SetState(181)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(176)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
				{
					p.SetState(175)
					p.Fws()
				}

			}
			{
				p.SetState(178)
				p.Ccontent()
			}

		}
		p.SetState(183)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())
	}
	p.SetState(185)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
		{
			p.SetState(184)
			p.Fws()
		}

	}
	{
		p.SetState(187)
		p.Match(RFC5322ParserRParens)
	}

	return localctx
}

// ICfwsContext is an interface to support dynamic dispatch.
type ICfwsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCfwsContext differentiates from other interfaces.
	IsCfwsContext()
}

type CfwsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCfwsContext() *CfwsContext {
	var p = new(CfwsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_cfws
	return p
}

func (*CfwsContext) IsCfwsContext() {}

func NewCfwsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CfwsContext {
	var p = new(CfwsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_cfws

	return p
}

func (s *CfwsContext) GetParser() antlr.Parser { return s.parser }

func (s *CfwsContext) AllComment() []ICommentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommentContext)(nil)).Elem())
	var tst = make([]ICommentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommentContext)
		}
	}

	return tst
}

func (s *CfwsContext) Comment(i int) ICommentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CfwsContext) AllFws() []IFwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFwsContext)(nil)).Elem())
	var tst = make([]IFwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFwsContext)
		}
	}

	return tst
}

func (s *CfwsContext) Fws(i int) IFwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *CfwsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CfwsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CfwsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterCfws(s)
	}
}

func (s *CfwsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitCfws(s)
	}
}

func (p *RFC5322Parser) Cfws() (localctx ICfwsContext) {
	localctx = NewCfwsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, RFC5322ParserRULE_cfws)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(201)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(193)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(190)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
					{
						p.SetState(189)
						p.Fws()
					}

				}
				{
					p.SetState(192)
					p.Comment()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(195)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
		}
		p.SetState(198)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(197)
				p.Fws()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(200)
			p.Fws()
		}

	}

	return localctx
}

// IAtextContext is an interface to support dynamic dispatch.
type IAtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtextContext differentiates from other interfaces.
	IsAtextContext()
}

type AtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtextContext() *AtextContext {
	var p = new(AtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_atext
	return p
}

func (*AtextContext) IsAtextContext() {}

func NewAtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtextContext {
	var p = new(AtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_atext

	return p
}

func (s *AtextContext) GetParser() antlr.Parser { return s.parser }

func (s *AtextContext) Alpha() IAlphaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *AtextContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *AtextContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *AtextContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *AtextContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *AtextContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *AtextContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *AtextContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *AtextContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *AtextContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *AtextContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *AtextContext) Slash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSlash, 0)
}

func (s *AtextContext) Equal() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, 0)
}

func (s *AtextContext) Question() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQuestion, 0)
}

func (s *AtextContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *AtextContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *AtextContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *AtextContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *AtextContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *AtextContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *AtextContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *AtextContext) UTF8NonAscii() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUTF8NonAscii, 0)
}

func (s *AtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAtext(s)
	}
}

func (s *AtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAtext(s)
	}
}

func (p *RFC5322Parser) Atext() (localctx IAtextContext) {
	localctx = NewAtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, RFC5322ParserRULE_atext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(225)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(203)
			p.Alpha()
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(204)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(205)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(206)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(207)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(208)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(209)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(210)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(211)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(212)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(213)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserSlash:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(214)
			p.Match(RFC5322ParserSlash)
		}

	case RFC5322ParserEqual:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(215)
			p.Match(RFC5322ParserEqual)
		}

	case RFC5322ParserQuestion:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(216)
			p.Match(RFC5322ParserQuestion)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(217)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(218)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(219)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(220)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(221)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(222)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(223)
			p.Match(RFC5322ParserTilde)
		}

	case RFC5322ParserUTF8NonAscii:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(224)
			p.Match(RFC5322ParserUTF8NonAscii)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) AllAtext() []IAtextContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtextContext)(nil)).Elem())
	var tst = make([]IAtextContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtextContext)
		}
	}

	return tst
}

func (s *AtomContext) Atext(i int) IAtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtextContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtextContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *RFC5322Parser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, RFC5322ParserRULE_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(228)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(227)
				p.Atext()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(230)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
	}

	return localctx
}

// IDotAtomContext is an interface to support dynamic dispatch.
type IDotAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotAtomContext differentiates from other interfaces.
	IsDotAtomContext()
}

type DotAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotAtomContext() *DotAtomContext {
	var p = new(DotAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_dotAtom
	return p
}

func (*DotAtomContext) IsDotAtomContext() {}

func NewDotAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DotAtomContext {
	var p = new(DotAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_dotAtom

	return p
}

func (s *DotAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *DotAtomContext) AllAtext() []IAtextContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtextContext)(nil)).Elem())
	var tst = make([]IAtextContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtextContext)
		}
	}

	return tst
}

func (s *DotAtomContext) Atext(i int) IAtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtextContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtextContext)
}

func (s *DotAtomContext) AllPeriod() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserPeriod)
}

func (s *DotAtomContext) Period(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, i)
}

func (s *DotAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DotAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DotAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDotAtom(s)
	}
}

func (s *DotAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDotAtom(s)
	}
}

func (p *RFC5322Parser) DotAtom() (localctx IDotAtomContext) {
	localctx = NewDotAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, RFC5322ParserRULE_dotAtom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(233)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(RFC5322ParserExclamation-10))|(1<<(RFC5322ParserHash-10))|(1<<(RFC5322ParserDollar-10))|(1<<(RFC5322ParserPercent-10))|(1<<(RFC5322ParserAmpersand-10))|(1<<(RFC5322ParserSQuote-10))|(1<<(RFC5322ParserAsterisk-10))|(1<<(RFC5322ParserPlus-10))|(1<<(RFC5322ParserMinus-10))|(1<<(RFC5322ParserSlash-10))|(1<<(RFC5322ParserDigit-10))|(1<<(RFC5322ParserEqual-10))|(1<<(RFC5322ParserQuestion-10))|(1<<(RFC5322ParserCaret-10))|(1<<(RFC5322ParserUnderscore-10))|(1<<(RFC5322ParserBacktick-10))|(1<<(RFC5322ParserLCurly-10))|(1<<(RFC5322ParserPipe-10))|(1<<(RFC5322ParserRCurly-10)))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(RFC5322ParserTilde-42))|(1<<(RFC5322ParserUTF8NonAscii-42))|(1<<(RFC5322ParserA-42))|(1<<(RFC5322ParserB-42))|(1<<(RFC5322ParserC-42))|(1<<(RFC5322ParserD-42))|(1<<(RFC5322ParserE-42))|(1<<(RFC5322ParserF-42))|(1<<(RFC5322ParserG-42))|(1<<(RFC5322ParserH-42))|(1<<(RFC5322ParserI-42))|(1<<(RFC5322ParserJ-42))|(1<<(RFC5322ParserK-42))|(1<<(RFC5322ParserL-42))|(1<<(RFC5322ParserM-42))|(1<<(RFC5322ParserN-42))|(1<<(RFC5322ParserO-42))|(1<<(RFC5322ParserP-42))|(1<<(RFC5322ParserQ-42))|(1<<(RFC5322ParserR-42))|(1<<(RFC5322ParserS-42))|(1<<(RFC5322ParserT-42))|(1<<(RFC5322ParserU-42))|(1<<(RFC5322ParserV-42))|(1<<(RFC5322ParserW-42))|(1<<(RFC5322ParserX-42))|(1<<(RFC5322ParserY-42))|(1<<(RFC5322ParserZ-42)))) != 0) {
		{
			p.SetState(232)
			p.Atext()
		}

		p.SetState(235)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(245)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(237)
				p.Match(RFC5322ParserPeriod)
			}
			p.SetState(239)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(RFC5322ParserExclamation-10))|(1<<(RFC5322ParserHash-10))|(1<<(RFC5322ParserDollar-10))|(1<<(RFC5322ParserPercent-10))|(1<<(RFC5322ParserAmpersand-10))|(1<<(RFC5322ParserSQuote-10))|(1<<(RFC5322ParserAsterisk-10))|(1<<(RFC5322ParserPlus-10))|(1<<(RFC5322ParserMinus-10))|(1<<(RFC5322ParserSlash-10))|(1<<(RFC5322ParserDigit-10))|(1<<(RFC5322ParserEqual-10))|(1<<(RFC5322ParserQuestion-10))|(1<<(RFC5322ParserCaret-10))|(1<<(RFC5322ParserUnderscore-10))|(1<<(RFC5322ParserBacktick-10))|(1<<(RFC5322ParserLCurly-10))|(1<<(RFC5322ParserPipe-10))|(1<<(RFC5322ParserRCurly-10)))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(RFC5322ParserTilde-42))|(1<<(RFC5322ParserUTF8NonAscii-42))|(1<<(RFC5322ParserA-42))|(1<<(RFC5322ParserB-42))|(1<<(RFC5322ParserC-42))|(1<<(RFC5322ParserD-42))|(1<<(RFC5322ParserE-42))|(1<<(RFC5322ParserF-42))|(1<<(RFC5322ParserG-42))|(1<<(RFC5322ParserH-42))|(1<<(RFC5322ParserI-42))|(1<<(RFC5322ParserJ-42))|(1<<(RFC5322ParserK-42))|(1<<(RFC5322ParserL-42))|(1<<(RFC5322ParserM-42))|(1<<(RFC5322ParserN-42))|(1<<(RFC5322ParserO-42))|(1<<(RFC5322ParserP-42))|(1<<(RFC5322ParserQ-42))|(1<<(RFC5322ParserR-42))|(1<<(RFC5322ParserS-42))|(1<<(RFC5322ParserT-42))|(1<<(RFC5322ParserU-42))|(1<<(RFC5322ParserV-42))|(1<<(RFC5322ParserW-42))|(1<<(RFC5322ParserX-42))|(1<<(RFC5322ParserY-42))|(1<<(RFC5322ParserZ-42)))) != 0) {
				{
					p.SetState(238)
					p.Atext()
				}

				p.SetState(241)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(247)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
	}
	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == RFC5322ParserPeriod {
		{
			p.SetState(248)
			p.Match(RFC5322ParserPeriod)
		}

	}

	return localctx
}

// IQtextContext is an interface to support dynamic dispatch.
type IQtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQtextContext differentiates from other interfaces.
	IsQtextContext()
}

type QtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQtextContext() *QtextContext {
	var p = new(QtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_qtext
	return p
}

func (*QtextContext) IsQtextContext() {}

func NewQtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QtextContext {
	var p = new(QtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_qtext

	return p
}

func (s *QtextContext) GetParser() antlr.Parser { return s.parser }

func (s *QtextContext) Alpha() IAlphaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *QtextContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *QtextContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *QtextContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *QtextContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *QtextContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *QtextContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *QtextContext) LParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLParens, 0)
}

func (s *QtextContext) RParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRParens, 0)
}

func (s *QtextContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *QtextContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *QtextContext) Comma() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, 0)
}

func (s *QtextContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *QtextContext) Period() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, 0)
}

func (s *QtextContext) Slash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSlash, 0)
}

func (s *QtextContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *QtextContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *QtextContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSemicolon, 0)
}

func (s *QtextContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *QtextContext) Equal() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, 0)
}

func (s *QtextContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *QtextContext) Question() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQuestion, 0)
}

func (s *QtextContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *QtextContext) LBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLBracket, 0)
}

func (s *QtextContext) RBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRBracket, 0)
}

func (s *QtextContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *QtextContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *QtextContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *QtextContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *QtextContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *QtextContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *QtextContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *QtextContext) ObsQtext() IObsQtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsQtextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsQtextContext)
}

func (s *QtextContext) UTF8NonAscii() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUTF8NonAscii, 0)
}

func (s *QtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterQtext(s)
	}
}

func (s *QtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitQtext(s)
	}
}

func (p *RFC5322Parser) Qtext() (localctx IQtextContext) {
	localctx = NewQtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, RFC5322ParserRULE_qtext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(285)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(251)
			p.Alpha()
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(252)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(253)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(254)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(255)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(256)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(257)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserLParens:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(258)
			p.Match(RFC5322ParserLParens)
		}

	case RFC5322ParserRParens:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(259)
			p.Match(RFC5322ParserRParens)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(260)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(261)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserComma:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(262)
			p.Match(RFC5322ParserComma)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(263)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserPeriod:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(264)
			p.Match(RFC5322ParserPeriod)
		}

	case RFC5322ParserSlash:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(265)
			p.Match(RFC5322ParserSlash)
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(266)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserColon:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(267)
			p.Match(RFC5322ParserColon)
		}

	case RFC5322ParserSemicolon:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(268)
			p.Match(RFC5322ParserSemicolon)
		}

	case RFC5322ParserLess:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(269)
			p.Match(RFC5322ParserLess)
		}

	case RFC5322ParserEqual:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(270)
			p.Match(RFC5322ParserEqual)
		}

	case RFC5322ParserGreater:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(271)
			p.Match(RFC5322ParserGreater)
		}

	case RFC5322ParserQuestion:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(272)
			p.Match(RFC5322ParserQuestion)
		}

	case RFC5322ParserAt:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(273)
			p.Match(RFC5322ParserAt)
		}

	case RFC5322ParserLBracket:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(274)
			p.Match(RFC5322ParserLBracket)
		}

	case RFC5322ParserRBracket:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(275)
			p.Match(RFC5322ParserRBracket)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(276)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(277)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(278)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(279)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(280)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(281)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(282)
			p.Match(RFC5322ParserTilde)
		}

	case RFC5322ParserU_01_08, RFC5322ParserU_0B, RFC5322ParserU_0C, RFC5322ParserU_0E_1F, RFC5322ParserDelete:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(283)
			p.ObsQtext()
		}

	case RFC5322ParserUTF8NonAscii:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(284)
			p.Match(RFC5322ParserUTF8NonAscii)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQuotedContentContext is an interface to support dynamic dispatch.
type IQuotedContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuotedContentContext differentiates from other interfaces.
	IsQuotedContentContext()
}

type QuotedContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedContentContext() *QuotedContentContext {
	var p = new(QuotedContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_quotedContent
	return p
}

func (*QuotedContentContext) IsQuotedContentContext() {}

func NewQuotedContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedContentContext {
	var p = new(QuotedContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_quotedContent

	return p
}

func (s *QuotedContentContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedContentContext) Qtext() IQtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQtextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQtextContext)
}

func (s *QuotedContentContext) QuotedPair() IQuotedPairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuotedPairContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuotedPairContext)
}

func (s *QuotedContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterQuotedContent(s)
	}
}

func (s *QuotedContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitQuotedContent(s)
	}
}

func (p *RFC5322Parser) QuotedContent() (localctx IQuotedContentContext) {
	localctx = NewQuotedContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, RFC5322ParserRULE_quotedContent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(289)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserU_01_08, RFC5322ParserU_0B, RFC5322ParserU_0C, RFC5322ParserU_0E_1F, RFC5322ParserExclamation, RFC5322ParserHash, RFC5322ParserDollar, RFC5322ParserPercent, RFC5322ParserAmpersand, RFC5322ParserSQuote, RFC5322ParserLParens, RFC5322ParserRParens, RFC5322ParserAsterisk, RFC5322ParserPlus, RFC5322ParserComma, RFC5322ParserMinus, RFC5322ParserPeriod, RFC5322ParserSlash, RFC5322ParserDigit, RFC5322ParserColon, RFC5322ParserSemicolon, RFC5322ParserLess, RFC5322ParserEqual, RFC5322ParserGreater, RFC5322ParserQuestion, RFC5322ParserAt, RFC5322ParserLBracket, RFC5322ParserRBracket, RFC5322ParserCaret, RFC5322ParserUnderscore, RFC5322ParserBacktick, RFC5322ParserLCurly, RFC5322ParserPipe, RFC5322ParserRCurly, RFC5322ParserTilde, RFC5322ParserDelete, RFC5322ParserUTF8NonAscii, RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(287)
			p.Qtext()
		}

	case RFC5322ParserBackslash:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(288)
			p.QuotedPair()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQuotedValueContext is an interface to support dynamic dispatch.
type IQuotedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuotedValueContext differentiates from other interfaces.
	IsQuotedValueContext()
}

type QuotedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedValueContext() *QuotedValueContext {
	var p = new(QuotedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_quotedValue
	return p
}

func (*QuotedValueContext) IsQuotedValueContext() {}

func NewQuotedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedValueContext {
	var p = new(QuotedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_quotedValue

	return p
}

func (s *QuotedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedValueContext) AllQuotedContent() []IQuotedContentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuotedContentContext)(nil)).Elem())
	var tst = make([]IQuotedContentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuotedContentContext)
		}
	}

	return tst
}

func (s *QuotedValueContext) QuotedContent(i int) IQuotedContentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuotedContentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuotedContentContext)
}

func (s *QuotedValueContext) AllFws() []IFwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFwsContext)(nil)).Elem())
	var tst = make([]IFwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFwsContext)
		}
	}

	return tst
}

func (s *QuotedValueContext) Fws(i int) IFwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *QuotedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterQuotedValue(s)
	}
}

func (s *QuotedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitQuotedValue(s)
	}
}

func (p *RFC5322Parser) QuotedValue() (localctx IQuotedValueContext) {
	localctx = NewQuotedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, RFC5322ParserRULE_quotedValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(297)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(292)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
				{
					p.SetState(291)
					p.Fws()
				}

			}
			{
				p.SetState(294)
				p.QuotedContent()
			}

		}
		p.SetState(299)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())
	}

	return localctx
}

// IQuotedStringContext is an interface to support dynamic dispatch.
type IQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuotedStringContext differentiates from other interfaces.
	IsQuotedStringContext()
}

type QuotedStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedStringContext() *QuotedStringContext {
	var p = new(QuotedStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_quotedString
	return p
}

func (*QuotedStringContext) IsQuotedStringContext() {}

func NewQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedStringContext {
	var p = new(QuotedStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_quotedString

	return p
}

func (s *QuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedStringContext) AllDQuote() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserDQuote)
}

func (s *QuotedStringContext) DQuote(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDQuote, i)
}

func (s *QuotedStringContext) QuotedValue() IQuotedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuotedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuotedValueContext)
}

func (s *QuotedStringContext) Fws() IFwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *QuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterQuotedString(s)
	}
}

func (s *QuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitQuotedString(s)
	}
}

func (p *RFC5322Parser) QuotedString() (localctx IQuotedStringContext) {
	localctx = NewQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, RFC5322ParserRULE_quotedString)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(300)
		p.Match(RFC5322ParserDQuote)
	}
	{
		p.SetState(301)
		p.QuotedValue()
	}
	p.SetState(303)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
		{
			p.SetState(302)
			p.Fws()
		}

	}
	{
		p.SetState(305)
		p.Match(RFC5322ParserDQuote)
	}

	return localctx
}

// IWordContext is an interface to support dynamic dispatch.
type IWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWordContext differentiates from other interfaces.
	IsWordContext()
}

type WordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWordContext() *WordContext {
	var p = new(WordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_word
	return p
}

func (*WordContext) IsWordContext() {}

func NewWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WordContext {
	var p = new(WordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_word

	return p
}

func (s *WordContext) GetParser() antlr.Parser { return s.parser }

func (s *WordContext) EncodedWord() IEncodedWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEncodedWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEncodedWordContext)
}

func (s *WordContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *WordContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *WordContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *WordContext) QuotedString() IQuotedStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuotedStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuotedStringContext)
}

func (s *WordContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *WordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterWord(s)
	}
}

func (s *WordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitWord(s)
	}
}

func (p *RFC5322Parser) Word() (localctx IWordContext) {
	localctx = NewWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, RFC5322ParserRULE_word)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(307)
				p.Cfws()
			}

		}
		{
			p.SetState(310)
			p.EncodedWord()
		}
		p.SetState(312)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(311)
				p.Cfws()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(315)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(314)
				p.Cfws()
			}

		}
		{
			p.SetState(317)
			p.Atom()
		}
		p.SetState(319)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(318)
				p.Cfws()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(322)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(321)
				p.Cfws()
			}

		}
		{
			p.SetState(324)
			p.QuotedString()
		}
		p.SetState(326)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(325)
				p.Cfws()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(328)
			p.Match(RFC5322ParserAt)
		}

	}

	return localctx
}

// IAddressContext is an interface to support dynamic dispatch.
type IAddressContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddressContext differentiates from other interfaces.
	IsAddressContext()
}

type AddressContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddressContext() *AddressContext {
	var p = new(AddressContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_address
	return p
}

func (*AddressContext) IsAddressContext() {}

func NewAddressContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddressContext {
	var p = new(AddressContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_address

	return p
}

func (s *AddressContext) GetParser() antlr.Parser { return s.parser }

func (s *AddressContext) Mailbox() IMailboxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMailboxContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMailboxContext)
}

func (s *AddressContext) Group() IGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupContext)
}

func (s *AddressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddressContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddressContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAddress(s)
	}
}

func (s *AddressContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAddress(s)
	}
}

func (p *RFC5322Parser) Address() (localctx IAddressContext) {
	localctx = NewAddressContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, RFC5322ParserRULE_address)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(331)
			p.Mailbox()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(332)
			p.Group()
		}

	}

	return localctx
}

// IMailboxContext is an interface to support dynamic dispatch.
type IMailboxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMailboxContext differentiates from other interfaces.
	IsMailboxContext()
}

type MailboxContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMailboxContext() *MailboxContext {
	var p = new(MailboxContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_mailbox
	return p
}

func (*MailboxContext) IsMailboxContext() {}

func NewMailboxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MailboxContext {
	var p = new(MailboxContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_mailbox

	return p
}

func (s *MailboxContext) GetParser() antlr.Parser { return s.parser }

func (s *MailboxContext) NameAddr() INameAddrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameAddrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameAddrContext)
}

func (s *MailboxContext) AddrSpec() IAddrSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddrSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddrSpecContext)
}

func (s *MailboxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MailboxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MailboxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterMailbox(s)
	}
}

func (s *MailboxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitMailbox(s)
	}
}

func (p *RFC5322Parser) Mailbox() (localctx IMailboxContext) {
	localctx = NewMailboxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, RFC5322ParserRULE_mailbox)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(335)
			p.NameAddr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(336)
			p.AddrSpec()
		}

	}

	return localctx
}

// INameAddrContext is an interface to support dynamic dispatch.
type INameAddrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameAddrContext differentiates from other interfaces.
	IsNameAddrContext()
}

type NameAddrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameAddrContext() *NameAddrContext {
	var p = new(NameAddrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_nameAddr
	return p
}

func (*NameAddrContext) IsNameAddrContext() {}

func NewNameAddrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameAddrContext {
	var p = new(NameAddrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_nameAddr

	return p
}

func (s *NameAddrContext) GetParser() antlr.Parser { return s.parser }

func (s *NameAddrContext) AngleAddr() IAngleAddrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAngleAddrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAngleAddrContext)
}

func (s *NameAddrContext) DisplayName() IDisplayNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplayNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplayNameContext)
}

func (s *NameAddrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameAddrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameAddrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterNameAddr(s)
	}
}

func (s *NameAddrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitNameAddr(s)
	}
}

func (p *RFC5322Parser) NameAddr() (localctx INameAddrContext) {
	localctx = NewNameAddrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, RFC5322ParserRULE_nameAddr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(340)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(339)
			p.DisplayName()
		}

	}
	{
		p.SetState(342)
		p.AngleAddr()
	}

	return localctx
}

// IAngleAddrContext is an interface to support dynamic dispatch.
type IAngleAddrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAngleAddrContext differentiates from other interfaces.
	IsAngleAddrContext()
}

type AngleAddrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAngleAddrContext() *AngleAddrContext {
	var p = new(AngleAddrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_angleAddr
	return p
}

func (*AngleAddrContext) IsAngleAddrContext() {}

func NewAngleAddrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AngleAddrContext {
	var p = new(AngleAddrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_angleAddr

	return p
}

func (s *AngleAddrContext) GetParser() antlr.Parser { return s.parser }

func (s *AngleAddrContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *AngleAddrContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *AngleAddrContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *AngleAddrContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *AngleAddrContext) AddrSpec() IAddrSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddrSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddrSpecContext)
}

func (s *AngleAddrContext) ObsAngleAddr() IObsAngleAddrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsAngleAddrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsAngleAddrContext)
}

func (s *AngleAddrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AngleAddrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AngleAddrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAngleAddr(s)
	}
}

func (s *AngleAddrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAngleAddr(s)
	}
}

func (p *RFC5322Parser) AngleAddr() (localctx IAngleAddrContext) {
	localctx = NewAngleAddrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, RFC5322ParserRULE_angleAddr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(345)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(344)
				p.Cfws()
			}

		}
		{
			p.SetState(347)
			p.Match(RFC5322ParserLess)
		}
		p.SetState(349)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserExclamation)|(1<<RFC5322ParserDQuote)|(1<<RFC5322ParserHash)|(1<<RFC5322ParserDollar)|(1<<RFC5322ParserPercent)|(1<<RFC5322ParserAmpersand)|(1<<RFC5322ParserSQuote)|(1<<RFC5322ParserLParens)|(1<<RFC5322ParserAsterisk)|(1<<RFC5322ParserPlus)|(1<<RFC5322ParserMinus)|(1<<RFC5322ParserSlash)|(1<<RFC5322ParserDigit)|(1<<RFC5322ParserEqual)|(1<<RFC5322ParserQuestion))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(RFC5322ParserAt-32))|(1<<(RFC5322ParserCaret-32))|(1<<(RFC5322ParserUnderscore-32))|(1<<(RFC5322ParserBacktick-32))|(1<<(RFC5322ParserLCurly-32))|(1<<(RFC5322ParserPipe-32))|(1<<(RFC5322ParserRCurly-32))|(1<<(RFC5322ParserTilde-32))|(1<<(RFC5322ParserUTF8NonAscii-32))|(1<<(RFC5322ParserA-32))|(1<<(RFC5322ParserB-32))|(1<<(RFC5322ParserC-32))|(1<<(RFC5322ParserD-32))|(1<<(RFC5322ParserE-32))|(1<<(RFC5322ParserF-32))|(1<<(RFC5322ParserG-32))|(1<<(RFC5322ParserH-32))|(1<<(RFC5322ParserI-32))|(1<<(RFC5322ParserJ-32))|(1<<(RFC5322ParserK-32))|(1<<(RFC5322ParserL-32))|(1<<(RFC5322ParserM-32))|(1<<(RFC5322ParserN-32))|(1<<(RFC5322ParserO-32))|(1<<(RFC5322ParserP-32))|(1<<(RFC5322ParserQ-32))|(1<<(RFC5322ParserR-32))|(1<<(RFC5322ParserS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(RFC5322ParserT-64))|(1<<(RFC5322ParserU-64))|(1<<(RFC5322ParserV-64))|(1<<(RFC5322ParserW-64))|(1<<(RFC5322ParserX-64))|(1<<(RFC5322ParserY-64))|(1<<(RFC5322ParserZ-64)))) != 0) {
			{
				p.SetState(348)
				p.AddrSpec()
			}

		}
		{
			p.SetState(351)
			p.Match(RFC5322ParserGreater)
		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(352)
				p.Cfws()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(355)
			p.ObsAngleAddr()
		}

	}

	return localctx
}

// IGroupContext is an interface to support dynamic dispatch.
type IGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupContext differentiates from other interfaces.
	IsGroupContext()
}

type GroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupContext() *GroupContext {
	var p = new(GroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_group
	return p
}

func (*GroupContext) IsGroupContext() {}

func NewGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupContext {
	var p = new(GroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_group

	return p
}

func (s *GroupContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupContext) DisplayName() IDisplayNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplayNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplayNameContext)
}

func (s *GroupContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *GroupContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSemicolon, 0)
}

func (s *GroupContext) GroupList() IGroupListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupListContext)
}

func (s *GroupContext) Cfws() ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *GroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterGroup(s)
	}
}

func (s *GroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitGroup(s)
	}
}

func (p *RFC5322Parser) Group() (localctx IGroupContext) {
	localctx = NewGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, RFC5322ParserRULE_group)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(358)
		p.DisplayName()
	}
	{
		p.SetState(359)
		p.Match(RFC5322ParserColon)
	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserExclamation)|(1<<RFC5322ParserDQuote)|(1<<RFC5322ParserHash)|(1<<RFC5322ParserDollar)|(1<<RFC5322ParserPercent)|(1<<RFC5322ParserAmpersand)|(1<<RFC5322ParserSQuote)|(1<<RFC5322ParserLParens)|(1<<RFC5322ParserAsterisk)|(1<<RFC5322ParserPlus)|(1<<RFC5322ParserComma)|(1<<RFC5322ParserMinus)|(1<<RFC5322ParserSlash)|(1<<RFC5322ParserDigit)|(1<<RFC5322ParserLess)|(1<<RFC5322ParserEqual)|(1<<RFC5322ParserQuestion))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(RFC5322ParserAt-32))|(1<<(RFC5322ParserCaret-32))|(1<<(RFC5322ParserUnderscore-32))|(1<<(RFC5322ParserBacktick-32))|(1<<(RFC5322ParserLCurly-32))|(1<<(RFC5322ParserPipe-32))|(1<<(RFC5322ParserRCurly-32))|(1<<(RFC5322ParserTilde-32))|(1<<(RFC5322ParserUTF8NonAscii-32))|(1<<(RFC5322ParserA-32))|(1<<(RFC5322ParserB-32))|(1<<(RFC5322ParserC-32))|(1<<(RFC5322ParserD-32))|(1<<(RFC5322ParserE-32))|(1<<(RFC5322ParserF-32))|(1<<(RFC5322ParserG-32))|(1<<(RFC5322ParserH-32))|(1<<(RFC5322ParserI-32))|(1<<(RFC5322ParserJ-32))|(1<<(RFC5322ParserK-32))|(1<<(RFC5322ParserL-32))|(1<<(RFC5322ParserM-32))|(1<<(RFC5322ParserN-32))|(1<<(RFC5322ParserO-32))|(1<<(RFC5322ParserP-32))|(1<<(RFC5322ParserQ-32))|(1<<(RFC5322ParserR-32))|(1<<(RFC5322ParserS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(RFC5322ParserT-64))|(1<<(RFC5322ParserU-64))|(1<<(RFC5322ParserV-64))|(1<<(RFC5322ParserW-64))|(1<<(RFC5322ParserX-64))|(1<<(RFC5322ParserY-64))|(1<<(RFC5322ParserZ-64)))) != 0) {
		{
			p.SetState(360)
			p.GroupList()
		}

	}
	{
		p.SetState(363)
		p.Match(RFC5322ParserSemicolon)
	}
	p.SetState(365)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
		{
			p.SetState(364)
			p.Cfws()
		}

	}

	return localctx
}

// IDisplayNameContext is an interface to support dynamic dispatch.
type IDisplayNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayNameContext differentiates from other interfaces.
	IsDisplayNameContext()
}

type DisplayNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayNameContext() *DisplayNameContext {
	var p = new(DisplayNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_displayName
	return p
}

func (*DisplayNameContext) IsDisplayNameContext() {}

func NewDisplayNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayNameContext {
	var p = new(DisplayNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_displayName

	return p
}

func (s *DisplayNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayNameContext) AllWord() []IWordContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWordContext)(nil)).Elem())
	var tst = make([]IWordContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWordContext)
		}
	}

	return tst
}

func (s *DisplayNameContext) Word(i int) IWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWordContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWordContext)
}

func (s *DisplayNameContext) AllPeriod() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserPeriod)
}

func (s *DisplayNameContext) Period(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, i)
}

func (s *DisplayNameContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *DisplayNameContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *DisplayNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDisplayName(s)
	}
}

func (s *DisplayNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDisplayName(s)
	}
}

func (p *RFC5322Parser) DisplayName() (localctx IDisplayNameContext) {
	localctx = NewDisplayNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, RFC5322ParserRULE_displayName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(381)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(368)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(367)
					p.Word()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(370)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(372)
			p.Word()
		}
		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(376)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(373)
						p.Word()
					}

				case 2:
					{
						p.SetState(374)
						p.Match(RFC5322ParserPeriod)
					}

				case 3:
					{
						p.SetState(375)
						p.Cfws()
					}

				}

			}
			p.SetState(380)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IMailboxListContext is an interface to support dynamic dispatch.
type IMailboxListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMailboxListContext differentiates from other interfaces.
	IsMailboxListContext()
}

type MailboxListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMailboxListContext() *MailboxListContext {
	var p = new(MailboxListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_mailboxList
	return p
}

func (*MailboxListContext) IsMailboxListContext() {}

func NewMailboxListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MailboxListContext {
	var p = new(MailboxListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_mailboxList

	return p
}

func (s *MailboxListContext) GetParser() antlr.Parser { return s.parser }

func (s *MailboxListContext) AllMailbox() []IMailboxContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMailboxContext)(nil)).Elem())
	var tst = make([]IMailboxContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMailboxContext)
		}
	}

	return tst
}

func (s *MailboxListContext) Mailbox(i int) IMailboxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMailboxContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMailboxContext)
}

func (s *MailboxListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserComma)
}

func (s *MailboxListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, i)
}

func (s *MailboxListContext) ObsMboxList() IObsMboxListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsMboxListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsMboxListContext)
}

func (s *MailboxListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MailboxListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MailboxListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterMailboxList(s)
	}
}

func (s *MailboxListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitMailboxList(s)
	}
}

func (p *RFC5322Parser) MailboxList() (localctx IMailboxListContext) {
	localctx = NewMailboxListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, RFC5322ParserRULE_mailboxList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(383)
			p.Mailbox()
		}
		p.SetState(388)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == RFC5322ParserComma {
			{
				p.SetState(384)
				p.Match(RFC5322ParserComma)
			}
			{
				p.SetState(385)
				p.Mailbox()
			}

			p.SetState(390)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(391)
			p.ObsMboxList()
		}

	}

	return localctx
}

// IAddressListContext is an interface to support dynamic dispatch.
type IAddressListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddressListContext differentiates from other interfaces.
	IsAddressListContext()
}

type AddressListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddressListContext() *AddressListContext {
	var p = new(AddressListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_addressList
	return p
}

func (*AddressListContext) IsAddressListContext() {}

func NewAddressListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddressListContext {
	var p = new(AddressListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_addressList

	return p
}

func (s *AddressListContext) GetParser() antlr.Parser { return s.parser }

func (s *AddressListContext) AllAddress() []IAddressContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddressContext)(nil)).Elem())
	var tst = make([]IAddressContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddressContext)
		}
	}

	return tst
}

func (s *AddressListContext) Address(i int) IAddressContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddressContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddressContext)
}

func (s *AddressListContext) EOF() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEOF, 0)
}

func (s *AddressListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserComma)
}

func (s *AddressListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, i)
}

func (s *AddressListContext) ObsAddrList() IObsAddrListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsAddrListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsAddrListContext)
}

func (s *AddressListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddressListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddressListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAddressList(s)
	}
}

func (s *AddressListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAddressList(s)
	}
}

func (p *RFC5322Parser) AddressList() (localctx IAddressListContext) {
	localctx = NewAddressListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, RFC5322ParserRULE_addressList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(407)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(394)
			p.Address()
		}
		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == RFC5322ParserComma {
			{
				p.SetState(395)
				p.Match(RFC5322ParserComma)
			}
			{
				p.SetState(396)
				p.Address()
			}

			p.SetState(401)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(402)
			p.Match(RFC5322ParserEOF)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(404)
			p.ObsAddrList()
		}
		{
			p.SetState(405)
			p.Match(RFC5322ParserEOF)
		}

	}

	return localctx
}

// IGroupListContext is an interface to support dynamic dispatch.
type IGroupListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupListContext differentiates from other interfaces.
	IsGroupListContext()
}

type GroupListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupListContext() *GroupListContext {
	var p = new(GroupListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_groupList
	return p
}

func (*GroupListContext) IsGroupListContext() {}

func NewGroupListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupListContext {
	var p = new(GroupListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_groupList

	return p
}

func (s *GroupListContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupListContext) MailboxList() IMailboxListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMailboxListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMailboxListContext)
}

func (s *GroupListContext) Cfws() ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *GroupListContext) ObsGroupList() IObsGroupListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsGroupListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsGroupListContext)
}

func (s *GroupListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterGroupList(s)
	}
}

func (s *GroupListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitGroupList(s)
	}
}

func (p *RFC5322Parser) GroupList() (localctx IGroupListContext) {
	localctx = NewGroupListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, RFC5322ParserRULE_groupList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(409)
			p.MailboxList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(410)
			p.Cfws()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(411)
			p.ObsGroupList()
		}

	}

	return localctx
}

// IAddrSpecContext is an interface to support dynamic dispatch.
type IAddrSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddrSpecContext differentiates from other interfaces.
	IsAddrSpecContext()
}

type AddrSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddrSpecContext() *AddrSpecContext {
	var p = new(AddrSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_addrSpec
	return p
}

func (*AddrSpecContext) IsAddrSpecContext() {}

func NewAddrSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddrSpecContext {
	var p = new(AddrSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_addrSpec

	return p
}

func (s *AddrSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *AddrSpecContext) LocalPart() ILocalPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalPartContext)
}

func (s *AddrSpecContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *AddrSpecContext) Domain() IDomainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDomainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDomainContext)
}

func (s *AddrSpecContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *AddrSpecContext) Port() IPortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPortContext)
}

func (s *AddrSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddrSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddrSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAddrSpec(s)
	}
}

func (s *AddrSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAddrSpec(s)
	}
}

func (p *RFC5322Parser) AddrSpec() (localctx IAddrSpecContext) {
	localctx = NewAddrSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, RFC5322ParserRULE_addrSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.LocalPart()
	}
	{
		p.SetState(415)
		p.Match(RFC5322ParserAt)
	}
	{
		p.SetState(416)
		p.Domain()
	}
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == RFC5322ParserColon {
		{
			p.SetState(417)
			p.Match(RFC5322ParserColon)
		}
		{
			p.SetState(418)
			p.Port()
		}

	}

	return localctx
}

// ILocalPartContext is an interface to support dynamic dispatch.
type ILocalPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalPartContext differentiates from other interfaces.
	IsLocalPartContext()
}

type LocalPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalPartContext() *LocalPartContext {
	var p = new(LocalPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_localPart
	return p
}

func (*LocalPartContext) IsLocalPartContext() {}

func NewLocalPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalPartContext {
	var p = new(LocalPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_localPart

	return p
}

func (s *LocalPartContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalPartContext) DotAtom() IDotAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotAtomContext)
}

func (s *LocalPartContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *LocalPartContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *LocalPartContext) QuotedString() IQuotedStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuotedStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuotedStringContext)
}

func (s *LocalPartContext) ObsLocalPart() IObsLocalPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsLocalPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsLocalPartContext)
}

func (s *LocalPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterLocalPart(s)
	}
}

func (s *LocalPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitLocalPart(s)
	}
}

func (p *RFC5322Parser) LocalPart() (localctx ILocalPartContext) {
	localctx = NewLocalPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, RFC5322ParserRULE_localPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(421)
				p.Cfws()
			}

		}
		{
			p.SetState(424)
			p.DotAtom()
		}
		p.SetState(426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(425)
				p.Cfws()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(428)
				p.Cfws()
			}

		}
		{
			p.SetState(431)
			p.QuotedString()
		}
		p.SetState(433)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(432)
				p.Cfws()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(435)
			p.ObsLocalPart()
		}

	}

	return localctx
}

// IPortContext is an interface to support dynamic dispatch.
type IPortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPortContext differentiates from other interfaces.
	IsPortContext()
}

type PortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPortContext() *PortContext {
	var p = new(PortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_port
	return p
}

func (*PortContext) IsPortContext() {}

func NewPortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PortContext {
	var p = new(PortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_port

	return p
}

func (s *PortContext) GetParser() antlr.Parser { return s.parser }

func (s *PortContext) AllDigit() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserDigit)
}

func (s *PortContext) Digit(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, i)
}

func (s *PortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterPort(s)
	}
}

func (s *PortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitPort(s)
	}
}

func (p *RFC5322Parser) Port() (localctx IPortContext) {
	localctx = NewPortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, RFC5322ParserRULE_port)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(439)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == RFC5322ParserDigit {
		{
			p.SetState(438)
			p.Match(RFC5322ParserDigit)
		}

		p.SetState(441)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDomainContext is an interface to support dynamic dispatch.
type IDomainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDomainContext differentiates from other interfaces.
	IsDomainContext()
}

type DomainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDomainContext() *DomainContext {
	var p = new(DomainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_domain
	return p
}

func (*DomainContext) IsDomainContext() {}

func NewDomainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DomainContext {
	var p = new(DomainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_domain

	return p
}

func (s *DomainContext) GetParser() antlr.Parser { return s.parser }

func (s *DomainContext) DotAtom() IDotAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotAtomContext)
}

func (s *DomainContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *DomainContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *DomainContext) DomainLiteral() IDomainLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDomainLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDomainLiteralContext)
}

func (s *DomainContext) ObsDomain() IObsDomainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsDomainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsDomainContext)
}

func (s *DomainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DomainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DomainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDomain(s)
	}
}

func (s *DomainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDomain(s)
	}
}

func (p *RFC5322Parser) Domain() (localctx IDomainContext) {
	localctx = NewDomainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, RFC5322ParserRULE_domain)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(444)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(443)
				p.Cfws()
			}

		}
		{
			p.SetState(446)
			p.DotAtom()
		}
		p.SetState(448)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(447)
				p.Cfws()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(451)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(450)
				p.Cfws()
			}

		}
		{
			p.SetState(453)
			p.DomainLiteral()
		}
		p.SetState(455)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(454)
				p.Cfws()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(458)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(457)
				p.Cfws()
			}

		}
		{
			p.SetState(460)
			p.ObsDomain()
		}
		p.SetState(462)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(461)
				p.Cfws()
			}

		}

	}

	return localctx
}

// IDomainLiteralContext is an interface to support dynamic dispatch.
type IDomainLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDomainLiteralContext differentiates from other interfaces.
	IsDomainLiteralContext()
}

type DomainLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDomainLiteralContext() *DomainLiteralContext {
	var p = new(DomainLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_domainLiteral
	return p
}

func (*DomainLiteralContext) IsDomainLiteralContext() {}

func NewDomainLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DomainLiteralContext {
	var p = new(DomainLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_domainLiteral

	return p
}

func (s *DomainLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DomainLiteralContext) LBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLBracket, 0)
}

func (s *DomainLiteralContext) RBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRBracket, 0)
}

func (s *DomainLiteralContext) AllDtext() []IDtextContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDtextContext)(nil)).Elem())
	var tst = make([]IDtextContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDtextContext)
		}
	}

	return tst
}

func (s *DomainLiteralContext) Dtext(i int) IDtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtextContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDtextContext)
}

func (s *DomainLiteralContext) AllFws() []IFwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFwsContext)(nil)).Elem())
	var tst = make([]IFwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFwsContext)
		}
	}

	return tst
}

func (s *DomainLiteralContext) Fws(i int) IFwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *DomainLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DomainLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DomainLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDomainLiteral(s)
	}
}

func (s *DomainLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDomainLiteral(s)
	}
}

func (p *RFC5322Parser) DomainLiteral() (localctx IDomainLiteralContext) {
	localctx = NewDomainLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, RFC5322ParserRULE_domainLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(466)
		p.Match(RFC5322ParserLBracket)
	}
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(468)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
				{
					p.SetState(467)
					p.Fws()
				}

			}
			{
				p.SetState(470)
				p.Dtext()
			}

		}
		p.SetState(475)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
	}
	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
		{
			p.SetState(476)
			p.Fws()
		}

	}
	{
		p.SetState(479)
		p.Match(RFC5322ParserRBracket)
	}

	return localctx
}

// IDtextContext is an interface to support dynamic dispatch.
type IDtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDtextContext differentiates from other interfaces.
	IsDtextContext()
}

type DtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtextContext() *DtextContext {
	var p = new(DtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_dtext
	return p
}

func (*DtextContext) IsDtextContext() {}

func NewDtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DtextContext {
	var p = new(DtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_dtext

	return p
}

func (s *DtextContext) GetParser() antlr.Parser { return s.parser }

func (s *DtextContext) Alpha() IAlphaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *DtextContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *DtextContext) DQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDQuote, 0)
}

func (s *DtextContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *DtextContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *DtextContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *DtextContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *DtextContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *DtextContext) LParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLParens, 0)
}

func (s *DtextContext) RParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRParens, 0)
}

func (s *DtextContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *DtextContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *DtextContext) Comma() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, 0)
}

func (s *DtextContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *DtextContext) Period() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, 0)
}

func (s *DtextContext) Slash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSlash, 0)
}

func (s *DtextContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *DtextContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *DtextContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSemicolon, 0)
}

func (s *DtextContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *DtextContext) Equal() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, 0)
}

func (s *DtextContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *DtextContext) Question() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQuestion, 0)
}

func (s *DtextContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *DtextContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *DtextContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *DtextContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *DtextContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *DtextContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *DtextContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *DtextContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *DtextContext) UTF8NonAscii() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUTF8NonAscii, 0)
}

func (s *DtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDtext(s)
	}
}

func (s *DtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDtext(s)
	}
}

func (p *RFC5322Parser) Dtext() (localctx IDtextContext) {
	localctx = NewDtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, RFC5322ParserRULE_dtext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(513)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(481)
			p.Alpha()
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(482)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserDQuote:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(483)
			p.Match(RFC5322ParserDQuote)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(484)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(485)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(486)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(487)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(488)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserLParens:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(489)
			p.Match(RFC5322ParserLParens)
		}

	case RFC5322ParserRParens:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(490)
			p.Match(RFC5322ParserRParens)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(491)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(492)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserComma:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(493)
			p.Match(RFC5322ParserComma)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(494)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserPeriod:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(495)
			p.Match(RFC5322ParserPeriod)
		}

	case RFC5322ParserSlash:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(496)
			p.Match(RFC5322ParserSlash)
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(497)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserColon:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(498)
			p.Match(RFC5322ParserColon)
		}

	case RFC5322ParserSemicolon:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(499)
			p.Match(RFC5322ParserSemicolon)
		}

	case RFC5322ParserLess:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(500)
			p.Match(RFC5322ParserLess)
		}

	case RFC5322ParserEqual:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(501)
			p.Match(RFC5322ParserEqual)
		}

	case RFC5322ParserGreater:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(502)
			p.Match(RFC5322ParserGreater)
		}

	case RFC5322ParserQuestion:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(503)
			p.Match(RFC5322ParserQuestion)
		}

	case RFC5322ParserAt:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(504)
			p.Match(RFC5322ParserAt)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(505)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(506)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(507)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(508)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(509)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(510)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(511)
			p.Match(RFC5322ParserTilde)
		}

	case RFC5322ParserUTF8NonAscii:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(512)
			p.Match(RFC5322ParserUTF8NonAscii)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObsNoWSCTLContext is an interface to support dynamic dispatch.
type IObsNoWSCTLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsNoWSCTLContext differentiates from other interfaces.
	IsObsNoWSCTLContext()
}

type ObsNoWSCTLContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsNoWSCTLContext() *ObsNoWSCTLContext {
	var p = new(ObsNoWSCTLContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsNoWSCTL
	return p
}

func (*ObsNoWSCTLContext) IsObsNoWSCTLContext() {}

func NewObsNoWSCTLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsNoWSCTLContext {
	var p = new(ObsNoWSCTLContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsNoWSCTL

	return p
}

func (s *ObsNoWSCTLContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsNoWSCTLContext) U_01_08() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU_01_08, 0)
}

func (s *ObsNoWSCTLContext) U_0B() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU_0B, 0)
}

func (s *ObsNoWSCTLContext) U_0C() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU_0C, 0)
}

func (s *ObsNoWSCTLContext) U_0E_1F() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU_0E_1F, 0)
}

func (s *ObsNoWSCTLContext) Delete() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDelete, 0)
}

func (s *ObsNoWSCTLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsNoWSCTLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsNoWSCTLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsNoWSCTL(s)
	}
}

func (s *ObsNoWSCTLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsNoWSCTL(s)
	}
}

func (p *RFC5322Parser) ObsNoWSCTL() (localctx IObsNoWSCTLContext) {
	localctx = NewObsNoWSCTLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, RFC5322ParserRULE_obsNoWSCTL)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserU_01_08)|(1<<RFC5322ParserU_0B)|(1<<RFC5322ParserU_0C)|(1<<RFC5322ParserU_0E_1F))) != 0) || _la == RFC5322ParserDelete) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IObsCtextContext is an interface to support dynamic dispatch.
type IObsCtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsCtextContext differentiates from other interfaces.
	IsObsCtextContext()
}

type ObsCtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsCtextContext() *ObsCtextContext {
	var p = new(ObsCtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsCtext
	return p
}

func (*ObsCtextContext) IsObsCtextContext() {}

func NewObsCtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsCtextContext {
	var p = new(ObsCtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsCtext

	return p
}

func (s *ObsCtextContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsCtextContext) ObsNoWSCTL() IObsNoWSCTLContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsNoWSCTLContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsNoWSCTLContext)
}

func (s *ObsCtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsCtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsCtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsCtext(s)
	}
}

func (s *ObsCtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsCtext(s)
	}
}

func (p *RFC5322Parser) ObsCtext() (localctx IObsCtextContext) {
	localctx = NewObsCtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, RFC5322ParserRULE_obsCtext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(517)
		p.ObsNoWSCTL()
	}

	return localctx
}

// IObsQtextContext is an interface to support dynamic dispatch.
type IObsQtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsQtextContext differentiates from other interfaces.
	IsObsQtextContext()
}

type ObsQtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsQtextContext() *ObsQtextContext {
	var p = new(ObsQtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsQtext
	return p
}

func (*ObsQtextContext) IsObsQtextContext() {}

func NewObsQtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsQtextContext {
	var p = new(ObsQtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsQtext

	return p
}

func (s *ObsQtextContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsQtextContext) ObsNoWSCTL() IObsNoWSCTLContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsNoWSCTLContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsNoWSCTLContext)
}

func (s *ObsQtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsQtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsQtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsQtext(s)
	}
}

func (s *ObsQtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsQtext(s)
	}
}

func (p *RFC5322Parser) ObsQtext() (localctx IObsQtextContext) {
	localctx = NewObsQtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, RFC5322ParserRULE_obsQtext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(519)
		p.ObsNoWSCTL()
	}

	return localctx
}

// IObsQPContext is an interface to support dynamic dispatch.
type IObsQPContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsQPContext differentiates from other interfaces.
	IsObsQPContext()
}

type ObsQPContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsQPContext() *ObsQPContext {
	var p = new(ObsQPContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsQP
	return p
}

func (*ObsQPContext) IsObsQPContext() {}

func NewObsQPContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsQPContext {
	var p = new(ObsQPContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsQP

	return p
}

func (s *ObsQPContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsQPContext) Backslash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBackslash, 0)
}

func (s *ObsQPContext) U_00() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU_00, 0)
}

func (s *ObsQPContext) ObsNoWSCTL() IObsNoWSCTLContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsNoWSCTLContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsNoWSCTLContext)
}

func (s *ObsQPContext) LF() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLF, 0)
}

func (s *ObsQPContext) CR() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCR, 0)
}

func (s *ObsQPContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsQPContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsQPContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsQP(s)
	}
}

func (s *ObsQPContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsQP(s)
	}
}

func (p *RFC5322Parser) ObsQP() (localctx IObsQPContext) {
	localctx = NewObsQPContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, RFC5322ParserRULE_obsQP)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(521)
		p.Match(RFC5322ParserBackslash)
	}
	p.SetState(526)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserU_00:
		{
			p.SetState(522)
			p.Match(RFC5322ParserU_00)
		}

	case RFC5322ParserU_01_08, RFC5322ParserU_0B, RFC5322ParserU_0C, RFC5322ParserU_0E_1F, RFC5322ParserDelete:
		{
			p.SetState(523)
			p.ObsNoWSCTL()
		}

	case RFC5322ParserLF:
		{
			p.SetState(524)
			p.Match(RFC5322ParserLF)
		}

	case RFC5322ParserCR:
		{
			p.SetState(525)
			p.Match(RFC5322ParserCR)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObsFWSContext is an interface to support dynamic dispatch.
type IObsFWSContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsFWSContext differentiates from other interfaces.
	IsObsFWSContext()
}

type ObsFWSContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsFWSContext() *ObsFWSContext {
	var p = new(ObsFWSContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsFWS
	return p
}

func (*ObsFWSContext) IsObsFWSContext() {}

func NewObsFWSContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsFWSContext {
	var p = new(ObsFWSContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsFWS

	return p
}

func (s *ObsFWSContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsFWSContext) Crlf() ICrlfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrlfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *ObsFWSContext) AllWsp() []IWspContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWspContext)(nil)).Elem())
	var tst = make([]IWspContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWspContext)
		}
	}

	return tst
}

func (s *ObsFWSContext) Wsp(i int) IWspContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWspContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWspContext)
}

func (s *ObsFWSContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsFWSContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsFWSContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsFWS(s)
	}
}

func (s *ObsFWSContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsFWS(s)
	}
}

func (p *RFC5322Parser) ObsFWS() (localctx IObsFWSContext) {
	localctx = NewObsFWSContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, RFC5322ParserRULE_obsFWS)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(529)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == RFC5322ParserTAB || _la == RFC5322ParserSP {
		{
			p.SetState(528)
			p.Wsp()
		}

		p.SetState(531)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	{
		p.SetState(533)
		p.Crlf()
	}
	p.SetState(535)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(534)
				p.Wsp()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())
	}

	return localctx
}

// IObsAngleAddrContext is an interface to support dynamic dispatch.
type IObsAngleAddrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsAngleAddrContext differentiates from other interfaces.
	IsObsAngleAddrContext()
}

type ObsAngleAddrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsAngleAddrContext() *ObsAngleAddrContext {
	var p = new(ObsAngleAddrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsAngleAddr
	return p
}

func (*ObsAngleAddrContext) IsObsAngleAddrContext() {}

func NewObsAngleAddrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsAngleAddrContext {
	var p = new(ObsAngleAddrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsAngleAddr

	return p
}

func (s *ObsAngleAddrContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsAngleAddrContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *ObsAngleAddrContext) ObsRoute() IObsRouteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsRouteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsRouteContext)
}

func (s *ObsAngleAddrContext) AddrSpec() IAddrSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddrSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddrSpecContext)
}

func (s *ObsAngleAddrContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *ObsAngleAddrContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *ObsAngleAddrContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *ObsAngleAddrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsAngleAddrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsAngleAddrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsAngleAddr(s)
	}
}

func (s *ObsAngleAddrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsAngleAddr(s)
	}
}

func (p *RFC5322Parser) ObsAngleAddr() (localctx IObsAngleAddrContext) {
	localctx = NewObsAngleAddrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, RFC5322ParserRULE_obsAngleAddr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(540)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
		{
			p.SetState(539)
			p.Cfws()
		}

	}
	{
		p.SetState(542)
		p.Match(RFC5322ParserLess)
	}
	{
		p.SetState(543)
		p.ObsRoute()
	}
	{
		p.SetState(544)
		p.AddrSpec()
	}
	{
		p.SetState(545)
		p.Match(RFC5322ParserGreater)
	}
	p.SetState(547)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
		{
			p.SetState(546)
			p.Cfws()
		}

	}

	return localctx
}

// IObsRouteContext is an interface to support dynamic dispatch.
type IObsRouteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsRouteContext differentiates from other interfaces.
	IsObsRouteContext()
}

type ObsRouteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsRouteContext() *ObsRouteContext {
	var p = new(ObsRouteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsRoute
	return p
}

func (*ObsRouteContext) IsObsRouteContext() {}

func NewObsRouteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsRouteContext {
	var p = new(ObsRouteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsRoute

	return p
}

func (s *ObsRouteContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsRouteContext) ObsDomainList() IObsDomainListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObsDomainListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObsDomainListContext)
}

func (s *ObsRouteContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *ObsRouteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsRouteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsRouteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsRoute(s)
	}
}

func (s *ObsRouteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsRoute(s)
	}
}

func (p *RFC5322Parser) ObsRoute() (localctx IObsRouteContext) {
	localctx = NewObsRouteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, RFC5322ParserRULE_obsRoute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(549)
		p.ObsDomainList()
	}
	{
		p.SetState(550)
		p.Match(RFC5322ParserColon)
	}

	return localctx
}

// IObsDomainListContext is an interface to support dynamic dispatch.
type IObsDomainListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsDomainListContext differentiates from other interfaces.
	IsObsDomainListContext()
}

type ObsDomainListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsDomainListContext() *ObsDomainListContext {
	var p = new(ObsDomainListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsDomainList
	return p
}

func (*ObsDomainListContext) IsObsDomainListContext() {}

func NewObsDomainListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsDomainListContext {
	var p = new(ObsDomainListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsDomainList

	return p
}

func (s *ObsDomainListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsDomainListContext) AllAt() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserAt)
}

func (s *ObsDomainListContext) At(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, i)
}

func (s *ObsDomainListContext) AllDomain() []IDomainContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDomainContext)(nil)).Elem())
	var tst = make([]IDomainContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDomainContext)
		}
	}

	return tst
}

func (s *ObsDomainListContext) Domain(i int) IDomainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDomainContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDomainContext)
}

func (s *ObsDomainListContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *ObsDomainListContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *ObsDomainListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserComma)
}

func (s *ObsDomainListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, i)
}

func (s *ObsDomainListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsDomainListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsDomainListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsDomainList(s)
	}
}

func (s *ObsDomainListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsDomainList(s)
	}
}

func (p *RFC5322Parser) ObsDomainList() (localctx IObsDomainListContext) {
	localctx = NewObsDomainListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, RFC5322ParserRULE_obsDomainList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens)|(1<<RFC5322ParserComma))) != 0 {
		p.SetState(554)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case RFC5322ParserTAB, RFC5322ParserCR, RFC5322ParserSP, RFC5322ParserLParens:
			{
				p.SetState(552)
				p.Cfws()
			}

		case RFC5322ParserComma:
			{
				p.SetState(553)
				p.Match(RFC5322ParserComma)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(558)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(559)
		p.Match(RFC5322ParserAt)
	}
	{
		p.SetState(560)
		p.Domain()
	}
	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == RFC5322ParserComma {
		{
			p.SetState(561)
			p.Match(RFC5322ParserComma)
		}
		p.SetState(563)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(562)
				p.Cfws()
			}

		}
		p.SetState(567)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == RFC5322ParserAt {
			{
				p.SetState(565)
				p.Match(RFC5322ParserAt)
			}
			{
				p.SetState(566)
				p.Domain()
			}

		}

		p.SetState(573)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObsMboxListContext is an interface to support dynamic dispatch.
type IObsMboxListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsMboxListContext differentiates from other interfaces.
	IsObsMboxListContext()
}

type ObsMboxListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsMboxListContext() *ObsMboxListContext {
	var p = new(ObsMboxListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsMboxList
	return p
}

func (*ObsMboxListContext) IsObsMboxListContext() {}

func NewObsMboxListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsMboxListContext {
	var p = new(ObsMboxListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsMboxList

	return p
}

func (s *ObsMboxListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsMboxListContext) AllMailbox() []IMailboxContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMailboxContext)(nil)).Elem())
	var tst = make([]IMailboxContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMailboxContext)
		}
	}

	return tst
}

func (s *ObsMboxListContext) Mailbox(i int) IMailboxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMailboxContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMailboxContext)
}

func (s *ObsMboxListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserComma)
}

func (s *ObsMboxListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, i)
}

func (s *ObsMboxListContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *ObsMboxListContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *ObsMboxListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsMboxListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsMboxListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsMboxList(s)
	}
}

func (s *ObsMboxListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsMboxList(s)
	}
}

func (p *RFC5322Parser) ObsMboxList() (localctx IObsMboxListContext) {
	localctx = NewObsMboxListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, RFC5322ParserRULE_obsMboxList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(575)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
				{
					p.SetState(574)
					p.Cfws()
				}

			}
			{
				p.SetState(577)
				p.Match(RFC5322ParserComma)
			}

		}
		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())
	}
	{
		p.SetState(583)
		p.Mailbox()
	}
	p.SetState(591)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == RFC5322ParserComma {
		{
			p.SetState(584)
			p.Match(RFC5322ParserComma)
		}
		p.SetState(587)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(585)
				p.Mailbox()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(586)
				p.Cfws()
			}

		}

		p.SetState(593)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObsAddrListContext is an interface to support dynamic dispatch.
type IObsAddrListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsAddrListContext differentiates from other interfaces.
	IsObsAddrListContext()
}

type ObsAddrListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsAddrListContext() *ObsAddrListContext {
	var p = new(ObsAddrListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsAddrList
	return p
}

func (*ObsAddrListContext) IsObsAddrListContext() {}

func NewObsAddrListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsAddrListContext {
	var p = new(ObsAddrListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsAddrList

	return p
}

func (s *ObsAddrListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsAddrListContext) AllAddress() []IAddressContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddressContext)(nil)).Elem())
	var tst = make([]IAddressContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddressContext)
		}
	}

	return tst
}

func (s *ObsAddrListContext) Address(i int) IAddressContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddressContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddressContext)
}

func (s *ObsAddrListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserComma)
}

func (s *ObsAddrListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, i)
}

func (s *ObsAddrListContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *ObsAddrListContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *ObsAddrListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsAddrListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsAddrListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsAddrList(s)
	}
}

func (s *ObsAddrListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsAddrList(s)
	}
}

func (p *RFC5322Parser) ObsAddrList() (localctx IObsAddrListContext) {
	localctx = NewObsAddrListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, RFC5322ParserRULE_obsAddrList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(595)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
				{
					p.SetState(594)
					p.Cfws()
				}

			}
			{
				p.SetState(597)
				p.Match(RFC5322ParserComma)
			}

		}
		p.SetState(602)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext())
	}
	{
		p.SetState(603)
		p.Address()
	}
	p.SetState(611)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == RFC5322ParserComma {
		{
			p.SetState(604)
			p.Match(RFC5322ParserComma)
		}
		p.SetState(607)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(605)
				p.Address()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(606)
				p.Cfws()
			}

		}

		p.SetState(613)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObsGroupListContext is an interface to support dynamic dispatch.
type IObsGroupListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsGroupListContext differentiates from other interfaces.
	IsObsGroupListContext()
}

type ObsGroupListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsGroupListContext() *ObsGroupListContext {
	var p = new(ObsGroupListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsGroupList
	return p
}

func (*ObsGroupListContext) IsObsGroupListContext() {}

func NewObsGroupListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsGroupListContext {
	var p = new(ObsGroupListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsGroupList

	return p
}

func (s *ObsGroupListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsGroupListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserComma)
}

func (s *ObsGroupListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, i)
}

func (s *ObsGroupListContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *ObsGroupListContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *ObsGroupListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsGroupListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsGroupListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsGroupList(s)
	}
}

func (s *ObsGroupListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsGroupList(s)
	}
}

func (p *RFC5322Parser) ObsGroupList() (localctx IObsGroupListContext) {
	localctx = NewObsGroupListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, RFC5322ParserRULE_obsGroupList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(618)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(615)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
				{
					p.SetState(614)
					p.Cfws()
				}

			}
			{
				p.SetState(617)
				p.Match(RFC5322ParserComma)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(620)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())
	}
	p.SetState(623)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
		{
			p.SetState(622)
			p.Cfws()
		}

	}

	return localctx
}

// IObsLocalPartContext is an interface to support dynamic dispatch.
type IObsLocalPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsLocalPartContext differentiates from other interfaces.
	IsObsLocalPartContext()
}

type ObsLocalPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsLocalPartContext() *ObsLocalPartContext {
	var p = new(ObsLocalPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsLocalPart
	return p
}

func (*ObsLocalPartContext) IsObsLocalPartContext() {}

func NewObsLocalPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsLocalPartContext {
	var p = new(ObsLocalPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsLocalPart

	return p
}

func (s *ObsLocalPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsLocalPartContext) AllWord() []IWordContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWordContext)(nil)).Elem())
	var tst = make([]IWordContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWordContext)
		}
	}

	return tst
}

func (s *ObsLocalPartContext) Word(i int) IWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWordContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWordContext)
}

func (s *ObsLocalPartContext) AllPeriod() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserPeriod)
}

func (s *ObsLocalPartContext) Period(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, i)
}

func (s *ObsLocalPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsLocalPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsLocalPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsLocalPart(s)
	}
}

func (s *ObsLocalPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsLocalPart(s)
	}
}

func (p *RFC5322Parser) ObsLocalPart() (localctx IObsLocalPartContext) {
	localctx = NewObsLocalPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, RFC5322ParserRULE_obsLocalPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		p.Word()
	}
	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == RFC5322ParserPeriod {
		{
			p.SetState(626)
			p.Match(RFC5322ParserPeriod)
		}
		{
			p.SetState(627)
			p.Word()
		}

		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObsDomainContext is an interface to support dynamic dispatch.
type IObsDomainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsDomainContext differentiates from other interfaces.
	IsObsDomainContext()
}

type ObsDomainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsDomainContext() *ObsDomainContext {
	var p = new(ObsDomainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsDomain
	return p
}

func (*ObsDomainContext) IsObsDomainContext() {}

func NewObsDomainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsDomainContext {
	var p = new(ObsDomainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsDomain

	return p
}

func (s *ObsDomainContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsDomainContext) AllAtom() []IAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtomContext)(nil)).Elem())
	var tst = make([]IAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtomContext)
		}
	}

	return tst
}

func (s *ObsDomainContext) Atom(i int) IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *ObsDomainContext) AllPeriod() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserPeriod)
}

func (s *ObsDomainContext) Period(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, i)
}

func (s *ObsDomainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsDomainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsDomainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsDomain(s)
	}
}

func (s *ObsDomainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsDomain(s)
	}
}

func (p *RFC5322Parser) ObsDomain() (localctx IObsDomainContext) {
	localctx = NewObsDomainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, RFC5322ParserRULE_obsDomain)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Atom()
	}
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == RFC5322ParserPeriod {
		{
			p.SetState(634)
			p.Match(RFC5322ParserPeriod)
		}
		{
			p.SetState(635)
			p.Atom()
		}

		p.SetState(640)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEncodedWordContext is an interface to support dynamic dispatch.
type IEncodedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncodedWordContext differentiates from other interfaces.
	IsEncodedWordContext()
}

type EncodedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncodedWordContext() *EncodedWordContext {
	var p = new(EncodedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_encodedWord
	return p
}

func (*EncodedWordContext) IsEncodedWordContext() {}

func NewEncodedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EncodedWordContext {
	var p = new(EncodedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_encodedWord

	return p
}

func (s *EncodedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *EncodedWordContext) AllEqual() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserEqual)
}

func (s *EncodedWordContext) Equal(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, i)
}

func (s *EncodedWordContext) AllQuestion() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserQuestion)
}

func (s *EncodedWordContext) Question(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQuestion, i)
}

func (s *EncodedWordContext) Charset() ICharsetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharsetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharsetContext)
}

func (s *EncodedWordContext) Encoding() IEncodingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEncodingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEncodingContext)
}

func (s *EncodedWordContext) EncodedText() IEncodedTextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEncodedTextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEncodedTextContext)
}

func (s *EncodedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncodedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EncodedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterEncodedWord(s)
	}
}

func (s *EncodedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitEncodedWord(s)
	}
}

func (p *RFC5322Parser) EncodedWord() (localctx IEncodedWordContext) {
	localctx = NewEncodedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, RFC5322ParserRULE_encodedWord)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		p.Match(RFC5322ParserEqual)
	}
	{
		p.SetState(642)
		p.Match(RFC5322ParserQuestion)
	}
	{
		p.SetState(643)
		p.Charset()
	}
	{
		p.SetState(644)
		p.Match(RFC5322ParserQuestion)
	}
	{
		p.SetState(645)
		p.Encoding()
	}
	{
		p.SetState(646)
		p.Match(RFC5322ParserQuestion)
	}
	{
		p.SetState(647)
		p.EncodedText()
	}
	{
		p.SetState(648)
		p.Match(RFC5322ParserQuestion)
	}
	{
		p.SetState(649)
		p.Match(RFC5322ParserEqual)
	}

	return localctx
}

// ICharsetContext is an interface to support dynamic dispatch.
type ICharsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharsetContext differentiates from other interfaces.
	IsCharsetContext()
}

type CharsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetContext() *CharsetContext {
	var p = new(CharsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_charset
	return p
}

func (*CharsetContext) IsCharsetContext() {}

func NewCharsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetContext {
	var p = new(CharsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_charset

	return p
}

func (s *CharsetContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetContext) Token() ITokenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokenContext)
}

func (s *CharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterCharset(s)
	}
}

func (s *CharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitCharset(s)
	}
}

func (p *RFC5322Parser) Charset() (localctx ICharsetContext) {
	localctx = NewCharsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, RFC5322ParserRULE_charset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.Token()
	}

	return localctx
}

// IEncodingContext is an interface to support dynamic dispatch.
type IEncodingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncodingContext differentiates from other interfaces.
	IsEncodingContext()
}

type EncodingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncodingContext() *EncodingContext {
	var p = new(EncodingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_encoding
	return p
}

func (*EncodingContext) IsEncodingContext() {}

func NewEncodingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EncodingContext {
	var p = new(EncodingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_encoding

	return p
}

func (s *EncodingContext) GetParser() antlr.Parser { return s.parser }

func (s *EncodingContext) Token() ITokenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokenContext)
}

func (s *EncodingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncodingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EncodingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterEncoding(s)
	}
}

func (s *EncodingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitEncoding(s)
	}
}

func (p *RFC5322Parser) Encoding() (localctx IEncodingContext) {
	localctx = NewEncodingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, RFC5322ParserRULE_encoding)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(653)
		p.Token()
	}

	return localctx
}

// ITokenContext is an interface to support dynamic dispatch.
type ITokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokenContext differentiates from other interfaces.
	IsTokenContext()
}

type TokenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokenContext() *TokenContext {
	var p = new(TokenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_token
	return p
}

func (*TokenContext) IsTokenContext() {}

func NewTokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokenContext {
	var p = new(TokenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_token

	return p
}

func (s *TokenContext) GetParser() antlr.Parser { return s.parser }

func (s *TokenContext) AllTokenChar() []ITokenCharContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITokenCharContext)(nil)).Elem())
	var tst = make([]ITokenCharContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITokenCharContext)
		}
	}

	return tst
}

func (s *TokenContext) TokenChar(i int) ITokenCharContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokenCharContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITokenCharContext)
}

func (s *TokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterToken(s)
	}
}

func (s *TokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitToken(s)
	}
}

func (p *RFC5322Parser) Token() (localctx ITokenContext) {
	localctx = NewTokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, RFC5322ParserRULE_token)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(656)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(RFC5322ParserExclamation-10))|(1<<(RFC5322ParserHash-10))|(1<<(RFC5322ParserDollar-10))|(1<<(RFC5322ParserPercent-10))|(1<<(RFC5322ParserAmpersand-10))|(1<<(RFC5322ParserSQuote-10))|(1<<(RFC5322ParserAsterisk-10))|(1<<(RFC5322ParserPlus-10))|(1<<(RFC5322ParserMinus-10))|(1<<(RFC5322ParserDigit-10))|(1<<(RFC5322ParserBackslash-10))|(1<<(RFC5322ParserCaret-10))|(1<<(RFC5322ParserUnderscore-10))|(1<<(RFC5322ParserBacktick-10))|(1<<(RFC5322ParserLCurly-10))|(1<<(RFC5322ParserPipe-10))|(1<<(RFC5322ParserRCurly-10)))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(RFC5322ParserTilde-42))|(1<<(RFC5322ParserA-42))|(1<<(RFC5322ParserB-42))|(1<<(RFC5322ParserC-42))|(1<<(RFC5322ParserD-42))|(1<<(RFC5322ParserE-42))|(1<<(RFC5322ParserF-42))|(1<<(RFC5322ParserG-42))|(1<<(RFC5322ParserH-42))|(1<<(RFC5322ParserI-42))|(1<<(RFC5322ParserJ-42))|(1<<(RFC5322ParserK-42))|(1<<(RFC5322ParserL-42))|(1<<(RFC5322ParserM-42))|(1<<(RFC5322ParserN-42))|(1<<(RFC5322ParserO-42))|(1<<(RFC5322ParserP-42))|(1<<(RFC5322ParserQ-42))|(1<<(RFC5322ParserR-42))|(1<<(RFC5322ParserS-42))|(1<<(RFC5322ParserT-42))|(1<<(RFC5322ParserU-42))|(1<<(RFC5322ParserV-42))|(1<<(RFC5322ParserW-42))|(1<<(RFC5322ParserX-42))|(1<<(RFC5322ParserY-42))|(1<<(RFC5322ParserZ-42)))) != 0) {
		{
			p.SetState(655)
			p.TokenChar()
		}

		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITokenCharContext is an interface to support dynamic dispatch.
type ITokenCharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokenCharContext differentiates from other interfaces.
	IsTokenCharContext()
}

type TokenCharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokenCharContext() *TokenCharContext {
	var p = new(TokenCharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_tokenChar
	return p
}

func (*TokenCharContext) IsTokenCharContext() {}

func NewTokenCharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokenCharContext {
	var p = new(TokenCharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_tokenChar

	return p
}

func (s *TokenCharContext) GetParser() antlr.Parser { return s.parser }

func (s *TokenCharContext) Alpha() IAlphaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *TokenCharContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *TokenCharContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *TokenCharContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *TokenCharContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *TokenCharContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *TokenCharContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *TokenCharContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *TokenCharContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *TokenCharContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *TokenCharContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *TokenCharContext) Backslash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBackslash, 0)
}

func (s *TokenCharContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *TokenCharContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *TokenCharContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *TokenCharContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *TokenCharContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *TokenCharContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *TokenCharContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *TokenCharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokenCharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokenCharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterTokenChar(s)
	}
}

func (s *TokenCharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitTokenChar(s)
	}
}

func (p *RFC5322Parser) TokenChar() (localctx ITokenCharContext) {
	localctx = NewTokenCharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, RFC5322ParserRULE_tokenChar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(679)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(660)
			p.Alpha()
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(661)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(662)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(663)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(664)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(665)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(666)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(667)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(668)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(669)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(670)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserBackslash:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(671)
			p.Match(RFC5322ParserBackslash)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(672)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(673)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(674)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(675)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(676)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(677)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(678)
			p.Match(RFC5322ParserTilde)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEncodedTextContext is an interface to support dynamic dispatch.
type IEncodedTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncodedTextContext differentiates from other interfaces.
	IsEncodedTextContext()
}

type EncodedTextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncodedTextContext() *EncodedTextContext {
	var p = new(EncodedTextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_encodedText
	return p
}

func (*EncodedTextContext) IsEncodedTextContext() {}

func NewEncodedTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EncodedTextContext {
	var p = new(EncodedTextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_encodedText

	return p
}

func (s *EncodedTextContext) GetParser() antlr.Parser { return s.parser }

func (s *EncodedTextContext) AllEncodedChar() []IEncodedCharContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEncodedCharContext)(nil)).Elem())
	var tst = make([]IEncodedCharContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEncodedCharContext)
		}
	}

	return tst
}

func (s *EncodedTextContext) EncodedChar(i int) IEncodedCharContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEncodedCharContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEncodedCharContext)
}

func (s *EncodedTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncodedTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EncodedTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterEncodedText(s)
	}
}

func (s *EncodedTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitEncodedText(s)
	}
}

func (p *RFC5322Parser) EncodedText() (localctx IEncodedTextContext) {
	localctx = NewEncodedTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, RFC5322ParserRULE_encodedText)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(682)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(RFC5322ParserExclamation-10))|(1<<(RFC5322ParserDQuote-10))|(1<<(RFC5322ParserHash-10))|(1<<(RFC5322ParserDollar-10))|(1<<(RFC5322ParserPercent-10))|(1<<(RFC5322ParserAmpersand-10))|(1<<(RFC5322ParserSQuote-10))|(1<<(RFC5322ParserLParens-10))|(1<<(RFC5322ParserRParens-10))|(1<<(RFC5322ParserAsterisk-10))|(1<<(RFC5322ParserPlus-10))|(1<<(RFC5322ParserComma-10))|(1<<(RFC5322ParserMinus-10))|(1<<(RFC5322ParserPeriod-10))|(1<<(RFC5322ParserSlash-10))|(1<<(RFC5322ParserDigit-10))|(1<<(RFC5322ParserColon-10))|(1<<(RFC5322ParserSemicolon-10))|(1<<(RFC5322ParserLess-10))|(1<<(RFC5322ParserEqual-10))|(1<<(RFC5322ParserGreater-10))|(1<<(RFC5322ParserAt-10))|(1<<(RFC5322ParserLBracket-10))|(1<<(RFC5322ParserBackslash-10))|(1<<(RFC5322ParserRBracket-10))|(1<<(RFC5322ParserCaret-10))|(1<<(RFC5322ParserUnderscore-10))|(1<<(RFC5322ParserBacktick-10))|(1<<(RFC5322ParserLCurly-10))|(1<<(RFC5322ParserPipe-10))|(1<<(RFC5322ParserRCurly-10)))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(RFC5322ParserTilde-42))|(1<<(RFC5322ParserA-42))|(1<<(RFC5322ParserB-42))|(1<<(RFC5322ParserC-42))|(1<<(RFC5322ParserD-42))|(1<<(RFC5322ParserE-42))|(1<<(RFC5322ParserF-42))|(1<<(RFC5322ParserG-42))|(1<<(RFC5322ParserH-42))|(1<<(RFC5322ParserI-42))|(1<<(RFC5322ParserJ-42))|(1<<(RFC5322ParserK-42))|(1<<(RFC5322ParserL-42))|(1<<(RFC5322ParserM-42))|(1<<(RFC5322ParserN-42))|(1<<(RFC5322ParserO-42))|(1<<(RFC5322ParserP-42))|(1<<(RFC5322ParserQ-42))|(1<<(RFC5322ParserR-42))|(1<<(RFC5322ParserS-42))|(1<<(RFC5322ParserT-42))|(1<<(RFC5322ParserU-42))|(1<<(RFC5322ParserV-42))|(1<<(RFC5322ParserW-42))|(1<<(RFC5322ParserX-42))|(1<<(RFC5322ParserY-42))|(1<<(RFC5322ParserZ-42)))) != 0) {
		{
			p.SetState(681)
			p.EncodedChar()
		}

		p.SetState(684)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEncodedCharContext is an interface to support dynamic dispatch.
type IEncodedCharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncodedCharContext differentiates from other interfaces.
	IsEncodedCharContext()
}

type EncodedCharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncodedCharContext() *EncodedCharContext {
	var p = new(EncodedCharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_encodedChar
	return p
}

func (*EncodedCharContext) IsEncodedCharContext() {}

func NewEncodedCharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EncodedCharContext {
	var p = new(EncodedCharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_encodedChar

	return p
}

func (s *EncodedCharContext) GetParser() antlr.Parser { return s.parser }

func (s *EncodedCharContext) Alpha() IAlphaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *EncodedCharContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *EncodedCharContext) DQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDQuote, 0)
}

func (s *EncodedCharContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *EncodedCharContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *EncodedCharContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *EncodedCharContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *EncodedCharContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *EncodedCharContext) LParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLParens, 0)
}

func (s *EncodedCharContext) RParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRParens, 0)
}

func (s *EncodedCharContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *EncodedCharContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *EncodedCharContext) Comma() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, 0)
}

func (s *EncodedCharContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *EncodedCharContext) Period() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, 0)
}

func (s *EncodedCharContext) Slash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSlash, 0)
}

func (s *EncodedCharContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *EncodedCharContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *EncodedCharContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSemicolon, 0)
}

func (s *EncodedCharContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *EncodedCharContext) Equal() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, 0)
}

func (s *EncodedCharContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *EncodedCharContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *EncodedCharContext) LBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLBracket, 0)
}

func (s *EncodedCharContext) Backslash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBackslash, 0)
}

func (s *EncodedCharContext) RBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRBracket, 0)
}

func (s *EncodedCharContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *EncodedCharContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *EncodedCharContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *EncodedCharContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *EncodedCharContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *EncodedCharContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *EncodedCharContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *EncodedCharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncodedCharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EncodedCharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterEncodedChar(s)
	}
}

func (s *EncodedCharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitEncodedChar(s)
	}
}

func (p *RFC5322Parser) EncodedChar() (localctx IEncodedCharContext) {
	localctx = NewEncodedCharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, RFC5322ParserRULE_encodedChar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(719)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(686)
			p.Alpha()
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(687)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserDQuote:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(688)
			p.Match(RFC5322ParserDQuote)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(689)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(690)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(691)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(692)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(693)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserLParens:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(694)
			p.Match(RFC5322ParserLParens)
		}

	case RFC5322ParserRParens:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(695)
			p.Match(RFC5322ParserRParens)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(696)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(697)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserComma:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(698)
			p.Match(RFC5322ParserComma)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(699)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserPeriod:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(700)
			p.Match(RFC5322ParserPeriod)
		}

	case RFC5322ParserSlash:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(701)
			p.Match(RFC5322ParserSlash)
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(702)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserColon:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(703)
			p.Match(RFC5322ParserColon)
		}

	case RFC5322ParserSemicolon:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(704)
			p.Match(RFC5322ParserSemicolon)
		}

	case RFC5322ParserLess:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(705)
			p.Match(RFC5322ParserLess)
		}

	case RFC5322ParserEqual:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(706)
			p.Match(RFC5322ParserEqual)
		}

	case RFC5322ParserGreater:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(707)
			p.Match(RFC5322ParserGreater)
		}

	case RFC5322ParserAt:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(708)
			p.Match(RFC5322ParserAt)
		}

	case RFC5322ParserLBracket:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(709)
			p.Match(RFC5322ParserLBracket)
		}

	case RFC5322ParserBackslash:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(710)
			p.Match(RFC5322ParserBackslash)
		}

	case RFC5322ParserRBracket:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(711)
			p.Match(RFC5322ParserRBracket)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(712)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(713)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(714)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(715)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(716)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(717)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(718)
			p.Match(RFC5322ParserTilde)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICrlfContext is an interface to support dynamic dispatch.
type ICrlfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCrlfContext differentiates from other interfaces.
	IsCrlfContext()
}

type CrlfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrlfContext() *CrlfContext {
	var p = new(CrlfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_crlf
	return p
}

func (*CrlfContext) IsCrlfContext() {}

func NewCrlfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrlfContext {
	var p = new(CrlfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_crlf

	return p
}

func (s *CrlfContext) GetParser() antlr.Parser { return s.parser }

func (s *CrlfContext) CR() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCR, 0)
}

func (s *CrlfContext) LF() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLF, 0)
}

func (s *CrlfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrlfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrlfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterCrlf(s)
	}
}

func (s *CrlfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitCrlf(s)
	}
}

func (p *RFC5322Parser) Crlf() (localctx ICrlfContext) {
	localctx = NewCrlfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, RFC5322ParserRULE_crlf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(721)
		p.Match(RFC5322ParserCR)
	}
	{
		p.SetState(722)
		p.Match(RFC5322ParserLF)
	}

	return localctx
}

// IWspContext is an interface to support dynamic dispatch.
type IWspContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWspContext differentiates from other interfaces.
	IsWspContext()
}

type WspContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWspContext() *WspContext {
	var p = new(WspContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_wsp
	return p
}

func (*WspContext) IsWspContext() {}

func NewWspContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WspContext {
	var p = new(WspContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_wsp

	return p
}

func (s *WspContext) GetParser() antlr.Parser { return s.parser }

func (s *WspContext) SP() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSP, 0)
}

func (s *WspContext) TAB() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTAB, 0)
}

func (s *WspContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WspContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WspContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterWsp(s)
	}
}

func (s *WspContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitWsp(s)
	}
}

func (p *RFC5322Parser) Wsp() (localctx IWspContext) {
	localctx = NewWspContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, RFC5322ParserRULE_wsp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(724)
		_la = p.GetTokenStream().LA(1)

		if !(_la == RFC5322ParserTAB || _la == RFC5322ParserSP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVcharContext is an interface to support dynamic dispatch.
type IVcharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVcharContext differentiates from other interfaces.
	IsVcharContext()
}

type VcharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVcharContext() *VcharContext {
	var p = new(VcharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_vchar
	return p
}

func (*VcharContext) IsVcharContext() {}

func NewVcharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VcharContext {
	var p = new(VcharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_vchar

	return p
}

func (s *VcharContext) GetParser() antlr.Parser { return s.parser }

func (s *VcharContext) Alpha() IAlphaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *VcharContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *VcharContext) DQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDQuote, 0)
}

func (s *VcharContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *VcharContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *VcharContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *VcharContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *VcharContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *VcharContext) LParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLParens, 0)
}

func (s *VcharContext) RParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRParens, 0)
}

func (s *VcharContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *VcharContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *VcharContext) Comma() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, 0)
}

func (s *VcharContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *VcharContext) Period() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, 0)
}

func (s *VcharContext) Slash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSlash, 0)
}

func (s *VcharContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *VcharContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *VcharContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSemicolon, 0)
}

func (s *VcharContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *VcharContext) Equal() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, 0)
}

func (s *VcharContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *VcharContext) Question() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQuestion, 0)
}

func (s *VcharContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *VcharContext) LBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLBracket, 0)
}

func (s *VcharContext) Backslash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBackslash, 0)
}

func (s *VcharContext) RBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRBracket, 0)
}

func (s *VcharContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *VcharContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *VcharContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *VcharContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *VcharContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *VcharContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *VcharContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *VcharContext) UTF8NonAscii() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUTF8NonAscii, 0)
}

func (s *VcharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VcharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VcharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterVchar(s)
	}
}

func (s *VcharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitVchar(s)
	}
}

func (p *RFC5322Parser) Vchar() (localctx IVcharContext) {
	localctx = NewVcharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, RFC5322ParserRULE_vchar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(761)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(726)
			p.Alpha()
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(727)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserDQuote:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(728)
			p.Match(RFC5322ParserDQuote)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(729)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(730)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(731)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(732)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(733)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserLParens:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(734)
			p.Match(RFC5322ParserLParens)
		}

	case RFC5322ParserRParens:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(735)
			p.Match(RFC5322ParserRParens)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(736)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(737)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserComma:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(738)
			p.Match(RFC5322ParserComma)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(739)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserPeriod:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(740)
			p.Match(RFC5322ParserPeriod)
		}

	case RFC5322ParserSlash:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(741)
			p.Match(RFC5322ParserSlash)
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(742)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserColon:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(743)
			p.Match(RFC5322ParserColon)
		}

	case RFC5322ParserSemicolon:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(744)
			p.Match(RFC5322ParserSemicolon)
		}

	case RFC5322ParserLess:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(745)
			p.Match(RFC5322ParserLess)
		}

	case RFC5322ParserEqual:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(746)
			p.Match(RFC5322ParserEqual)
		}

	case RFC5322ParserGreater:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(747)
			p.Match(RFC5322ParserGreater)
		}

	case RFC5322ParserQuestion:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(748)
			p.Match(RFC5322ParserQuestion)
		}

	case RFC5322ParserAt:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(749)
			p.Match(RFC5322ParserAt)
		}

	case RFC5322ParserLBracket:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(750)
			p.Match(RFC5322ParserLBracket)
		}

	case RFC5322ParserBackslash:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(751)
			p.Match(RFC5322ParserBackslash)
		}

	case RFC5322ParserRBracket:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(752)
			p.Match(RFC5322ParserRBracket)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(753)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(754)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(755)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(756)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(757)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(758)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(759)
			p.Match(RFC5322ParserTilde)
		}

	case RFC5322ParserUTF8NonAscii:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(760)
			p.Match(RFC5322ParserUTF8NonAscii)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlphaContext is an interface to support dynamic dispatch.
type IAlphaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphaContext differentiates from other interfaces.
	IsAlphaContext()
}

type AlphaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphaContext() *AlphaContext {
	var p = new(AlphaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_alpha
	return p
}

func (*AlphaContext) IsAlphaContext() {}

func NewAlphaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphaContext {
	var p = new(AlphaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_alpha

	return p
}

func (s *AlphaContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphaContext) A() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserA, 0)
}

func (s *AlphaContext) B() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserB, 0)
}

func (s *AlphaContext) C() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserC, 0)
}

func (s *AlphaContext) D() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserD, 0)
}

func (s *AlphaContext) E() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserE, 0)
}

func (s *AlphaContext) F() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserF, 0)
}

func (s *AlphaContext) G() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserG, 0)
}

func (s *AlphaContext) H() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserH, 0)
}

func (s *AlphaContext) I() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserI, 0)
}

func (s *AlphaContext) J() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserJ, 0)
}

func (s *AlphaContext) K() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserK, 0)
}

func (s *AlphaContext) L() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserL, 0)
}

func (s *AlphaContext) M() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserM, 0)
}

func (s *AlphaContext) N() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserN, 0)
}

func (s *AlphaContext) O() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserO, 0)
}

func (s *AlphaContext) P() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserP, 0)
}

func (s *AlphaContext) Q() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQ, 0)
}

func (s *AlphaContext) R() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserR, 0)
}

func (s *AlphaContext) S() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserS, 0)
}

func (s *AlphaContext) T() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserT, 0)
}

func (s *AlphaContext) U() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU, 0)
}

func (s *AlphaContext) V() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserV, 0)
}

func (s *AlphaContext) W() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserW, 0)
}

func (s *AlphaContext) X() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserX, 0)
}

func (s *AlphaContext) Y() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserY, 0)
}

func (s *AlphaContext) Z() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserZ, 0)
}

func (s *AlphaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAlpha(s)
	}
}

func (s *AlphaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAlpha(s)
	}
}

func (p *RFC5322Parser) Alpha() (localctx IAlphaContext) {
	localctx = NewAlphaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, RFC5322ParserRULE_alpha)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(763)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-45)&-(0x1f+1)) == 0 && ((1<<uint((_la-45)))&((1<<(RFC5322ParserA-45))|(1<<(RFC5322ParserB-45))|(1<<(RFC5322ParserC-45))|(1<<(RFC5322ParserD-45))|(1<<(RFC5322ParserE-45))|(1<<(RFC5322ParserF-45))|(1<<(RFC5322ParserG-45))|(1<<(RFC5322ParserH-45))|(1<<(RFC5322ParserI-45))|(1<<(RFC5322ParserJ-45))|(1<<(RFC5322ParserK-45))|(1<<(RFC5322ParserL-45))|(1<<(RFC5322ParserM-45))|(1<<(RFC5322ParserN-45))|(1<<(RFC5322ParserO-45))|(1<<(RFC5322ParserP-45))|(1<<(RFC5322ParserQ-45))|(1<<(RFC5322ParserR-45))|(1<<(RFC5322ParserS-45))|(1<<(RFC5322ParserT-45))|(1<<(RFC5322ParserU-45))|(1<<(RFC5322ParserV-45))|(1<<(RFC5322ParserW-45))|(1<<(RFC5322ParserX-45))|(1<<(RFC5322ParserY-45))|(1<<(RFC5322ParserZ-45)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
